This is guile.info, produced by makeinfo version 4.7 from guile.texi.

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* Guile Reference: (guile).     The Guile reference manual.
END-INFO-DIR-ENTRY

   Guile Reference Manual Copyright (C) 1996 Free Software Foundation
Copyright (C) 1997 Free Software Foundation
Copyright (C) 2000 Free Software Foundation
Copyright (C) 2001 Free Software Foundation
Copyright (C) 2002 Free Software Foundation Copyright (C) 2004 Free
Software Foundation

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: guile.info,  Node: Calling Scheme procedures from C,  Next: Mixing gh and scm APIs,  Prev: Memory allocation and garbage collection,  Up: GH

19.12 Calling Scheme procedures from C
======================================

Many of the Scheme primitives are available in the `gh_' interface;
they take and return objects of type SCM, and one could basically use
them to write C code that mimics Scheme code.

   I will list these routines here without much explanation, since what
they do is the same as documented in *Note R5RS: (r5rs)Standard
procedures.  But I will point out that when a procedure takes a
variable number of arguments (such as `gh_list'), you should pass the
constant SCM_UNDEFINED from C to signify the end of the list.

 -- Function: SCM gh_define (char *NAME, SCM VAL)
     Corresponds to the Scheme `(define name val)': it binds a value to
     the given name (which is a C string).  Returns the new object.

Pairs and lists
===============

 -- Function: SCM gh_cons (SCM A, SCM B)
 -- Function: SCM gh_list (SCM l0, SCM l1, ... , SCM_UNDEFINED)
     These correspond to the Scheme `(cons a b)' and `(list l0 l1 ...)'
     procedures.  Note that `gh_list()' is a C macro that invokes
     `scm_listify()'.

 -- Function: SCM gh_car (SCM OBJ)
 -- Function: SCM gh_cdr (SCM OBJ)
     ...

 -- Function: SCM gh_c[ad][ad][ad][ad]r (SCM OBJ)
     These correspond to the Scheme `(caadar ls)' procedures etc ...

 -- Function: SCM gh_set_car_x (SCM PAIR, SCM VALUE)
     Modifies the CAR of PAIR to be VALUE.  This is equivalent to the
     Scheme procedure `(set-car! ...)'.

 -- Function: SCM gh_set_cdr_x (SCM PAIR, SCM VALUE)
     Modifies the CDR of PAIR to be VALUE.  This is equivalent to the
     Scheme procedure `(set-cdr! ...)'.

 -- Function: unsigned long gh_length (SCM LS)
     Returns the length of the list.

 -- Function: SCM gh_append (SCM ARGS)
 -- Function: SCM gh_append2 (SCM L1, SCM L2)
 -- Function: SCM gh_append3 (SCM L1, SCM L2, L3)
 -- Function: SCM gh_append4 (SCM L1, SCM L2, L3, L4)
     `gh_append()' takes ARGS, which is a list of lists `(list1 list2
     ...)', and returns a list containing all the elements of the
     individual lists.

     A typical invocation of `gh_append()' to append 5 lists together
     would be
            gh_append(gh_list(l1, l2, l3, l4, l5, SCM_UNDEFINED));

     The functions `gh_append2()', `gh_append2()', `gh_append3()' and
     `gh_append4()' are convenience routines to make it easier for C
     programs to form the list of lists that goes as an argument to
     `gh_append()'.

 -- Function: SCM gh_reverse (SCM LS)
     Returns a new list that has the same elements as LS but in the
     reverse order.  Note that this is implemented as a macro which
     calls `scm_reverse()'.

 -- Function: SCM gh_list_tail (SCM LS, SCM K)
     Returns the sublist of LS with the last K elements.

 -- Function: SCM gh_list_ref (SCM LS, SCM K)
     Returns the Kth element of the list LS.

 -- Function: SCM gh_memq (SCM X, SCM LS)
 -- Function: SCM gh_memv (SCM X, SCM LS)
 -- Function: SCM gh_member (SCM X, SCM LS)
     These functions return the first sublist of LS whose CAR is X.
     They correspond to `(memq x ls)', `(memv x ls)' and `(member x
     ls)', and hence use (respectively) `eq?', `eqv?' and `equal?' to
     do comparisons.

     If X does not appear in LS, the value `SCM_BOOL_F' (not the empty
     list) is returned.

     Note that these functions are implemented as macros which call
     `scm_memq()', `scm_memv()' and `scm_member()' respectively.

 -- Function: SCM gh_assq (SCM X, SCM ALIST)
 -- Function: SCM gh_assv (SCM X, SCM ALIST)
 -- Function: SCM gh_assoc (SCM X, SCM ALIST)
     These functions search an "association list" (list of pairs) ALIST
     for the first pair whose CAR is X, and they return that pair.

     If no pair in ALIST has X as its CAR, the value `SCM_BOOL_F' (not
     the empty list) is returned.

     Note that these functions are implemented as macros which call
     `scm_assq()', `scm_assv()' and `scm_assoc()' respectively.

Symbols
=======

Vectors
=======

 -- Function: SCM gh_make_vector (SCM N, SCM FILL)
 -- Function: SCM gh_vector (SCM LS)
 -- Function: SCM gh_vector_ref (SCM V, SCM I)
 -- Function: SCM gh_vector_set (SCM V, SCM I, SCM VAL)
 -- Function: unsigned long gh_vector_length (SCM V)
 -- Function: SCM gh_list_to_vector (SCM LS)
     These correspond to the Scheme `(make-vector n fill)', `(vector a
     b c ...)' `(vector-ref v i)' `(vector-set v i value)'
     `(vector-length v)' `(list->vector ls)' procedures.

     The correspondence is not perfect for `gh_vector': this routine
     takes a list LS instead of the individual list elements, thus
     making it identical to `gh_list_to_vector'.

     There is also a difference in gh_vector_length: the value returned
     is a C `unsigned long' instead of an SCM object.

Procedures
==========

 -- Function: SCM gh_apply (SCM proc, SCM args)
     Call the Scheme procedure PROC, with the elements of ARGS as
     arguments.  ARGS must be a proper list.

 -- Function: SCM gh_call0 (SCM proc)
 -- Function: SCM gh_call1 (SCM proc, SCM arg)
 -- Function: SCM gh_call2 (SCM proc, SCM arg1, SCM arg2)
 -- Function: SCM gh_call3 (SCM proc, SCM arg1, SCM arg2, SCM arg3)
     Call the Scheme procedure PROC with no arguments (`gh_call0'), one
     argument (`gh_call1'), and so on.  You can get the same effect by
     wrapping the arguments up into a list, and calling `gh_apply';
     Guile provides these functions for convenience.

 -- Function: SCM gh_catch (SCM key, SCM thunk, SCM handler)
 -- Function: SCM gh_throw (SCM key, SCM args)
     Corresponds to the Scheme `catch' and `throw' procedures, which in
     Guile are provided as primitives.

 -- Function: SCM gh_is_eq (SCM a, SCM b)
 -- Function: SCM gh_is_eqv (SCM a, SCM b)
 -- Function: SCM gh_is_equal (SCM a, SCM b)
     These correspond to the Scheme `eq?', `eqv?' and `equal?'
     predicates.

 -- Function: int gh_obj_length (SCM OBJ)
     Returns the raw object length.

Data lookup
===========

For now I just include Tim Pierce's comments from the `gh_data.c' file;
it should be organized into a documentation of the two functions here.

     /* Data lookups between C and Scheme

        Look up a symbol with a given name, and return the object to which
        it is bound.  gh_lookup examines the Guile top level, and
        gh_module_lookup checks the module name space specified by the
        `vec' argument.

        The return value is the Scheme object to which SNAME is bound, or
        SCM_UNDEFINED if SNAME is not bound in the given context. [FIXME:
        should this be SCM_UNSPECIFIED?  Can a symbol ever legitimately be
        bound to SCM_UNDEFINED or SCM_UNSPECIFIED?  What is the difference?
        -twp] */


File: guile.info,  Node: Mixing gh and scm APIs,  Next: scm transition summary,  Prev: Calling Scheme procedures from C,  Up: GH

19.13 Mixing gh and scm APIs
============================


File: guile.info,  Node: scm transition summary,  Prev: Mixing gh and scm APIs,  Up: GH

19.14 Transitioning to the scm Interface
========================================

The following table summarizes the available information on how to
transition from the GH to the scm interface.  Where transitioning is not
completely straightforward, the table includes a reference to more
detailed documentation in the preceding sections.

Header file
     Use `#include <libguile.h>' instead of `#include <guile/gh.h>'.

Compiling and Linking
     Use `guile-config' to pick up the flags required to compile C or
     C++ code that uses `libguile', like so

          $(CC) -o prog.o -c prog.c `guile-config compile`

     If you are using libtool to link your executables, just use
     `-lguile' in your link command.  Libtool will expand this into the
     needed linker options automatically.  If you are not using
     libtool, use the `guile-config' program to query the needed
     options explicitly.  A linker command like

          $(CC) -o prog prog.o `guile-config link`

     should be all that is needed.  To link shared libraries that will
     be used as Guile Extensions, use libtool to control both the
     compilation and the link stage.

The `SCM' type
     No change: the scm interface also uses this type to represent an
     arbitrary Scheme value.

`SCM_BOOL_F' and `SCM_BOOL_T'
     No change.

`SCM_UNSPECIFIED' and `SCM_UNDEFINED'
     No change.

`gh_enter'
     Use `scm_boot_guile' instead, but note that `scm_boot_guile' has a
     slightly different calling convention from `gh_enter':
     `scm_boot_guile', and the main program function that you specify
     for `scm_boot_guile' to call, both take an additional CLOSURE
     parameter.  *Note Guile Initialization Functions:: for more
     details.

`gh_repl'
     Use `scm_shell' instead.

`gh_init'
     Use `scm_init_guile' instead.

`gh_eval_str'
     Use `scm_c_eval_string' instead.

`gh_eval_file' or `gh_load'
     Use `scm_c_primitive_load' instead.

`gh_new_procedure'
     Use `scm_c_define_gsubr' instead, but note that the arguments are
     in a different order: for `scm_c_define_gsubr' the C function
     pointer is the last argument.  *Note A Sample Guile Extension::
     for an example.

`gh_defer_ints' and `gh_allow_ints'
     Use `SCM_DEFER_INTS' and `SCM_ALLOW_INTS' instead.  Note that
     these macros are used without parentheses, as in `SCM_DEFER_INTS;'.

`gh_bool2scm'
     Use `SCM_BOOL' instead.

`gh_ulong2scm'
     Use `scm_ulong2num' instead.

`gh_long2scm'
     Use `scm_long2num' instead.

`gh_double2scm'
     Use `scm_make_real' instead.

`gh_char2scm'
     Use `SCM_MAKE_CHAR' instead.

`gh_str2scm'
     Use `scm_mem2string' instead.

`gh_str02scm'
     Use `scm_makfrom0str' instead.

`gh_set_substr'
     No direct scm equivalent.  [FIXME]

`gh_symbol2scm'
     Use `scm_str2symbol' instead.  [FIXME: inconsistent naming, should
     be `scm_str02symbol'.]

`gh_ints2scm' and `gh_doubles2scm'
     No direct scm equivalent.  [FIXME]

`gh_chars2byvect' and `gh_shorts2svect'
     No direct scm equivalent.  [FIXME]

`gh_longs2ivect' and `gh_ulongs2uvect'
     No direct scm equivalent.  [FIXME]

`gh_floats2fvect' and `gh_doubles2dvect'
     No direct scm equivalent.  [FIXME]

`gh_scm2bool'
     Use `SCM_NFALSEP' instead.

`gh_scm2int'
     Replace `gh_scm2int (OBJ)' by
          scm_num2int (OBJ, SCM_ARG1, STR)
     where STR is a C string that describes the context of the call.

`gh_scm2ulong'
     Replace `gh_scm2ulong (OBJ)' by
          scm_num2ulong (OBJ, SCM_ARG1, STR)
     where STR is a C string that describes the context of the call.

`gh_scm2long'
     Replace `gh_scm2long (OBJ)' by
          scm_num2long (OBJ, SCM_ARG1, STR)
     where STR is a C string that describes the context of the call.

`gh_scm2double'
     Replace `gh_scm2double (OBJ)' by
          scm_num2dbl (OBJ, STR)
     where STR is a C string that describes the context of the call.

`gh_scm2char'
     Use the `SCM_CHAR' macro instead, but note that `SCM_CHAR' does
     not check that its argument is actually a character.  To check that
     a `SCM' value is a character before using `SCM_CHAR' to extract
     the character value, use the `SCM_VALIDATE_CHAR' macro.

`gh_scm2newstr'
     No direct scm equivalent.  [FIXME]

`gh_get_substr'
     No direct scm equivalent.  [FIXME]

`gh_symbol2newstr'
     No direct scm equivalent.  [FIXME]

`gh_scm2chars'
     No direct scm equivalent.  [FIXME]

`gh_scm2shorts' and `gh_scm2longs'
     No direct scm equivalent.  [FIXME]

`gh_scm2floats' and `gh_scm2doubles'
     No direct scm equivalent.  [FIXME]

`gh_boolean_p'
     Use the `SCM_BOOLP' macro instead, or replace `gh_boolean_p (OBJ)'
     by
          SCM_NFALSEP (scm_boolean_p (OBJ))

`gh_symbol_p'
     Use the `SCM_SYMBOLP' macro instead, or replace `gh_symbol_p
     (OBJ)' by
          SCM_NFALSEP (scm_symbol_p (OBJ))

`gh_char_p'
     Use the `SCM_CHARP' macro instead, or replace `gh_char_p (OBJ)' by
          SCM_NFALSEP (scm_char_p (OBJ))

`gh_vector_p'
     Use the `SCM_VECTORP' macro instead, or replace `gh_vector_p
     (OBJ)' by
          SCM_NFALSEP (scm_vector_p (OBJ))

`gh_pair_p'
     Use the `SCM_CONSP' macro instead, or replace `gh_pair_p (OBJ)' by
          SCM_NFALSEP (scm_pair_p (OBJ))

`gh_number_p'
     Use the `SCM_NUMBERP' macro instead, or replace `gh_number_p
     (OBJ)' by
          SCM_NFALSEP (scm_number_p (OBJ))

`gh_string_p'
     Use the `SCM_STRINGP' macro instead, or replace `gh_string_p
     (OBJ)' by
          SCM_NFALSEP (scm_string_p (OBJ))

`gh_procedure_p'
     Replace `gh_procedure_p (OBJ)' by
          SCM_NFALSEP (scm_procedure_p (OBJ))

`gh_list_p'
     Replace `gh_list_p (OBJ)' by
          SCM_NFALSEP (scm_list_p (OBJ))

`gh_inexact_p'
     Use the `SCM_INEXACTP' macro instead, or replace `gh_inexact_p
     (OBJ)' by
          SCM_NFALSEP (scm_inexact_p (OBJ))

`gh_exact_p'
     Replace `gh_exact_p (OBJ)' by
          SCM_NFALSEP (scm_exact_p (OBJ))

`gh_eq_p'
     Use the `SCM_EQ_P' macro instead, or replace `gh_eq_p (X, Y)' by
          SCM_NFALSEP (scm_eq_p (X, Y))

`gh_eqv_p'
     Replace `gh_eqv_p (X, Y)' by
          SCM_NFALSEP (scm_eqv_p (X, Y))

`gh_equal_p'
     Replace `gh_equal_p (X, Y)' by
          SCM_NFALSEP (scm_equal_p (X, Y))

`gh_string_equal_p'
     Replace `gh_string_equal_p (X, Y)' by
          SCM_NFALSEP (scm_string_equal_p (X, Y))

`gh_null_p'
     Use the `SCM_NULLP' macro instead, or replace `gh_null_p (OBJ)' by
          SCM_NFALSEP (scm_null_p (OBJ))

`gh_cons'
     Use `scm_cons' instead.

`gh_car' and `gh_cdr'
     Use the `SCM_CAR' and `SCM_CDR' macros instead.

`gh_cxxr' and `gh_cxxxr'
     (Where each x is either `a' or `d'.)  Use the corresponding
     `SCM_CXXR' or `SCM_CXXXR' macro instead.

`gh_set_car_x' and `gh_set_cdr_x'
     Use `scm_set_car_x' and `scm_set_cdr_x' instead.

`gh_list'
     Use `scm_listify' instead.

`gh_length'
     Replace `gh_length (LST)' by
          scm_num2ulong (scm_length (LST), SCM_ARG1, STR)
     where STR is a C string that describes the context of the call.

`gh_append'
     Use `scm_append' instead.

`gh_append2', `gh_append3', `gh_append4'
     Replace `gh_appendN (L1, ..., LN)' by
          scm_append (scm_listify (L1, ..., LN, SCM_UNDEFINED))

`gh_reverse'
     Use `scm_reverse' instead.

`gh_list_tail' and `gh_list_ref'
     Use `scm_list_tail' and `scm_list_ref' instead.

`gh_memq', `gh_memv' and `gh_member'
     Use `scm_memq', `scm_memv' and `scm_member' instead.

`gh_assq', `gh_assv' and `gh_assoc'
     Use `scm_assq', `scm_assv' and `scm_assoc' instead.

`gh_make_vector'
     Use `scm_make_vector' instead.

`gh_vector' or `gh_list_to_vector'
     Use `scm_vector' instead.

`gh_vector_ref' and `gh_vector_set_x'
     Use `scm_vector_ref' and `scm_vector_set_x' instead.

`gh_vector_length'
     Use the `SCM_VECTOR_LENGTH' macro instead.

`gh_apply'
     Use `scm_apply' instead, but note that `scm_apply' takes an
     additional third argument that you should set to `SCM_EOL'.



File: guile.info,  Node: Reference Intro,  Next: API Overview,  Prev: GH,  Up: Top

Part IV: Guile API Reference
****************************

Guile provides an application programming interface ("API") to
developers in two core languages: Scheme and C.  This part of the manual
contains reference documentation for all of the functionality that is
available through both Scheme and C interfaces.


File: guile.info,  Node: API Overview,  Next: Simple Data Types,  Prev: Reference Intro,  Up: Top

20 Overview of the Guile API
****************************

Guile's application programming interface ("API") makes functionality
available that an application developer can use in either C or Scheme
programming.  The interface consists of "elements" that may be macros,
functions or variables in C, and procedures, variables, syntax or other
types of object in Scheme.  Broadly speaking, the interface as a whole
can be divided into three groups.

  1. Elements that are available equivalently as C functions or Scheme
     procedures.

  2. Elements that are only available as macros, functions or variables
     for C programming.

  3. Elements that are only available as procedures or other objects in
     Scheme.

   Functions/procedures in the first group are often known as
"primitives", "subrs" or "builtins".  An example is the `assq' Scheme
procedure, which is also available as `scm_assq' in C.

   Elements in the second and third groups exist because they provide
additional language-specific benefits in either Scheme or C.  Examples
are the C macro `SCM_CONSP', which is faster and more convenient in C
programming than the primitive `scm_pair_p', and the
procedure-with-setter `make-object-property', which provides a more
convenient property handling interface in Scheme than the primitives on
which it is based.

* Menu:

* Primitives::                  Identical function for Scheme and C.
* C Only::                      Elements only available in C.
* Scheme Only::                 Elements only available in Scheme.
* Reference Layout::            The layout of this part of the manual.


File: guile.info,  Node: Primitives,  Next: C Only,  Up: API Overview

20.1 Identical Function in both Scheme and C
============================================

They form the majority of the API, and allow both C and Scheme
programmers to perform identical operations.

   Scheme procedures marked "primitive functions" have a regular
interface when calling from C, reflected in two areas: the name of a C
function, and the convention for passing non-required arguments to this
function.

* Menu:

* Transforming Scheme name to C name::
* Structuring argument lists for C functions::


File: guile.info,  Node: Transforming Scheme name to C name,  Next: Structuring argument lists for C functions,  Up: Primitives

20.1.1 Transforming Scheme name to C name
-----------------------------------------

Normally, the name of a C function can be derived given its Scheme name,
using some simple textual transformations:

   * Replace `-' (hyphen) with `_' (underscore).

   * Replace `?' (question mark) with "_p".

   * Replace `!' (exclamation point) with "_x".

   * Replace internal `->' with "_to_".

   * Replace `<=' (less than or equal) with "_leq".

   * Replace `>=' (greater than or equal) with "_geq".

   * Replace `<' (less than) with "_less".

   * Replace `>' (greater than) with "_gr".

   * Replace `@' with "at". [Omit?]

   * Prefix with "gh_" (or "scm_" if you are ignoring the gh interface).

   * [Anything else?  -ttn, 2000/01/16 15:17:28]


   Here is an Emacs Lisp command that prompts for a Scheme function
name and inserts the corresponding C function name into the buffer.

     (defun insert-scheme-to-C (name &optional use-gh)
       "Transforms Scheme NAME, a string, to its C counterpart, and inserts it.
     Prefix arg non-nil means use \"gh_\" prefix, otherwise use \"scm_\" prefix."
       (interactive "sScheme name: \nP")
       (let ((transforms '(("-"  . "_")
                           ("?"  . "_p")
                           ("!"  . "_x")
                           ("->" . "_to_")
                           ("<=" . "_leq")
                           (">=" . "_geq")
                           ("<"  . "_less")
                           (">"  . "_gr")
                           ("@"  . "at"))))
         (while transforms
           (let ((trigger (concat "\\(.*\\)"
                                  (regexp-quote (caar transforms))
                                  "\\(.*\\)"))
                 (sub (cdar transforms))
                 (m nil))
             (while (setq m (string-match trigger name))
               (setq name (concat (match-string 1 name)
                                  sub
                                  (match-string 2 name)))))
           (setq transforms (cdr transforms))))
       (insert (if use-gh "gh_" "scm_") name))


File: guile.info,  Node: Structuring argument lists for C functions,  Prev: Transforming Scheme name to C name,  Up: Primitives

20.1.2 Structuring argument lists for C functions
-------------------------------------------------

The C function's arguments will be all of the Scheme procedure's
arguments, both required and optional; if the Scheme procedure takes a
"rest" argument, that will be a final argument to the C function.  The
C function's arguments, as well as its return type, will be `SCM'.


File: guile.info,  Node: C Only,  Next: Scheme Only,  Prev: Primitives,  Up: API Overview

20.2 Elements Available Only in C
=================================

For C this is usually a matter of better performance (e.g. the
`SCM_CONSP' macro) or of accepting C language types rather than the
generic `SCM'.


File: guile.info,  Node: Scheme Only,  Next: Reference Layout,  Prev: C Only,  Up: API Overview

20.3 Elements Available Only in Scheme
======================================


File: guile.info,  Node: Reference Layout,  Prev: Scheme Only,  Up: API Overview

20.4 Reference Material Layout
==============================

This part of the reference manual documents all of Guile's core
Scheme-level language and features in functionally-related groups.
Where a particular section of the manual includes both R5RS-compliant
parts and Guile-specific extensions, the text indicates which parts of
the documentation describe R5RS behaviour and which parts describe Guile
extensions.

   For a quick way of identifying the parts of Guile that implement
R5RS-compliant features, see the R5RS index: *Note R5RS Index::.


File: guile.info,  Node: Simple Data Types,  Next: Compound Data Types,  Prev: API Overview,  Up: Top

21 Simple Generic Data Types
****************************

This chapter describes those of Guile's simple data types which are
primarily used for their role as items of generic data.  By "simple" we
mean data types that are not primarily used as containers to hold other
data -- i.e. pairs, lists, vectors and so on.  For the documentation of
such "compound" data types, see *Note Compound Data Types::.

   One of the great strengths of Scheme is that there is no
straightforward distinction between "data" and "functionality".  For
example, Guile's support for dynamic linking could be described

   * either in a "data-centric" way, as the behaviour and properties of
     the "dynamically linked object" data type, and the operations that
     may be applied to instances of this type

   * or in a "functionality-centric" way, as the set of procedures that
     constitute Guile's support for dynamic linking, in the context of
     the module system.

   The contents of this chapter are, therefore, a matter of judgment.
By "generic", we mean to select those data types whose typical use as
_data_ in a wide variety of programming contexts is more important than
their use in the implementation of a particular piece of
_functionality_.  The last section of this chapter provides references
for all the data types that are documented not here but in a
"functionality-centric" way elsewhere in the manual.

* Menu:

* Booleans::                    True/false values.
* Numbers::                     Numerical data types.
* Characters::                  New character names.
* Strings::                     Special things about strings.
* Regular Expressions::         Pattern matching and substitution.
* Symbols::                     Symbols.
* Keywords::                    Self-quoting, customizable display keywords.
* Other Types::                 "Functionality-centric" data types.


File: guile.info,  Node: Booleans,  Next: Numbers,  Up: Simple Data Types

21.1 Booleans
=============

The two boolean values are `#t' for true and `#f' for false.

   Boolean values are returned by predicate procedures, such as the
general equality predicates `eq?', `eqv?' and `equal?' (*note
Equality::) and numerical and string comparison operators like
`string=?' (*note String Comparison::) and `<=' (*note Comparison::).

     (<= 3 8)
     =>
     #t

     (<= 3 -3)
     =>
     #f

     (equal? "house" "houses")
     =>
     #f

     (eq? #f #f)
     =>
     #t

   In test condition contexts like `if' and `cond' (*note if cond
case::), where a group of subexpressions will be evaluated only if a
CONDITION expression evaluates to "true", "true" means any value at all
except `#f'.

     (if #t "yes" "no")
     =>
     "yes"

     (if 0 "yes" "no")
     =>
     "yes"

     (if #f "yes" "no")
     =>
     "no"

   A result of this asymmetry is that typical Scheme source code more
often uses `#f' explicitly than `#t': `#f' is necessary to represent an
`if' or `cond' false value, whereas `#t' is not necessary to represent
an `if' or `cond' true value.

   It is important to note that `#f' is *not* equivalent to any other
Scheme value.  In particular, `#f' is not the same as the number 0
(like in C and C++), and not the same as the "empty list" (like in some
Lisp dialects).

   The `not' procedure returns the boolean inverse of its argument:

 -- Scheme Procedure: not x
 -- C Function: scm_not (x)
     Return `#t' iff X is `#f', else return `#f'.

   The `boolean?' procedure is a predicate that returns `#t' if its
argument is one of the boolean values, otherwise `#f'.

 -- Scheme Procedure: boolean? obj
 -- C Function: scm_boolean_p (obj)
     Return `#t' iff OBJ is either `#t' or `#f'.


File: guile.info,  Node: Numbers,  Next: Characters,  Prev: Booleans,  Up: Simple Data Types

21.2 Numerical data types
=========================

Guile supports a rich "tower" of numerical types -- integer, rational,
real and complex -- and provides an extensive set of mathematical and
scientific functions for operating on numerical data.  This section of
the manual documents those types and functions.

   You may also find it illuminating to read R5RS's presentation of
numbers in Scheme, which is particularly clear and accessible: see
*Note Numbers: (r5rs)Numbers.

* Menu:

* Numerical Tower::             Scheme's numerical "tower".
* Integers::                    Whole numbers.
* Reals and Rationals::         Real and rational numbers.
* Complex Numbers::             Complex numbers.
* Exactness::                   Exactness and inexactness.
* Number Syntax::               Read syntax for numerical data.
* Integer Operations::          Operations on integer values.
* Comparison::                  Comparison predicates.
* Conversion::                  Converting numbers to and from strings.
* Complex::                     Complex number operations.
* Arithmetic::                  Arithmetic functions.
* Scientific::                  Scientific functions.
* Primitive Numerics::          Primitive numeric functions.
* Bitwise Operations::          Logical AND, OR, NOT, and so on.
* Random::                      Random number generation.


File: guile.info,  Node: Numerical Tower,  Next: Integers,  Up: Numbers

21.2.1 Scheme's Numerical "Tower"
---------------------------------

Scheme's numerical "tower" consists of the following categories of
numbers:

   * integers (whole numbers)

   * rationals (the set of numbers that can be expressed as P/Q where P
     and Q are integers)

   * real numbers (the set of numbers that describes all possible
     positions along a one dimensional line)

   * complex numbers (the set of numbers that describes all possible
     positions in a two dimensional space)

   It is called a tower because each category "sits on" the one that
follows it, in the sense that every integer is also a rational, every
rational is also real, and every real number is also a complex number
(but with zero imaginary part).

   Of these, Guile implements integers, reals and complex numbers as
distinct types.  Rationals are implemented as regards the read syntax
for rational numbers that is specified by R5RS, but are immediately
converted by Guile to the corresponding real number.

   The `number?' predicate may be applied to any Scheme value to
discover whether the value is any of the supported numerical types.

 -- Scheme Procedure: number? obj
 -- C Function: scm_number_p (obj)
     Return `#t' if OBJ is any kind of number, else `#f'.

   For example:

     (number? 3)
     =>
     #t

     (number? "hello there!")
     =>
     #f

     (define pi 3.141592654)
     (number? pi)
     =>
     #t

   The next few subsections document each of Guile's numerical data
types in detail.


File: guile.info,  Node: Integers,  Next: Reals and Rationals,  Prev: Numerical Tower,  Up: Numbers

21.2.2 Integers
---------------

Integers are whole numbers, that is numbers with no fractional part,
such as 2, 83 and -3789.

   Integers in Guile can be arbitrarily big, as shown by the following
example.

     (define (factorial n)
       (let loop ((n n) (product 1))
         (if (= n 0)
             product
             (loop (- n 1) (* product n)))))

     (factorial 3)
     =>
     6

     (factorial 20)
     =>
     2432902008176640000

     (- (factorial 45))
     =>
     -119622220865480194561963161495657715064383733760000000000

   Readers whose background is in programming languages where integers
are limited by the need to fit into just 4 or 8 bytes of memory may find
this surprising, or suspect that Guile's representation of integers is
inefficient.  In fact, Guile achieves a near optimal balance of
convenience and efficiency by using the host computer's native
representation of integers where possible, and a more general
representation where the required number does not fit in the native
form.  Conversion between these two representations is automatic and
completely invisible to the Scheme level programmer.

 -- Scheme Procedure: integer? x
 -- C Function: scm_integer_p (x)
     Return `#t' if X is an integer number, else `#f'.

          (integer? 487)
          =>
          #t

          (integer? -3.4)
          =>
          #f


File: guile.info,  Node: Reals and Rationals,  Next: Complex Numbers,  Prev: Integers,  Up: Numbers

21.2.3 Real and Rational Numbers
--------------------------------

Mathematically, the real numbers are the set of numbers that describe
all possible points along a continuous, infinite, one-dimensional line.
The rational numbers are the set of all numbers that can be written as
fractions P/Q, where P and Q are integers.  All rational numbers are
also real, but there are real numbers that are not rational, for example
the square root of 2, and pi.

   Guile represents both real and rational numbers approximately using a
floating point encoding with limited precision.  Even though the actual
encoding is in binary, it may be helpful to think of it as a decimal
number with a limited number of significant figures and a decimal point
somewhere, since this corresponds to the standard notation for non-whole
numbers.  For example:

     0.34
     -0.00000142857931198
     -5648394822220000000000.0
     4.0

   The limited precision of Guile's encoding means that any "real"
number in Guile can be written in a rational form, by multiplying and
then dividing by sufficient powers of 10 (or in fact, 2).  For example,
`-0.00000142857931198' is the same as `142857931198' divided by
`100000000000000000'.  In Guile's current incarnation, therefore, the
`rational?' and `real?' predicates are equivalent.

   Another aspect of this equivalence is that Guile currently does not
preserve the exactness that is possible with rational arithmetic.  If
such exactness is needed, it is of course possible to implement exact
rational arithmetic at the Scheme level using Guile's arbitrary size
integers.

   A planned future revision of Guile's numerical tower will make it
possible to implement exact representations and arithmetic for both
rational numbers and real irrational numbers such as square roots, and
in such a way that the new kinds of number integrate seamlessly with
those that are already implemented.

 -- Scheme Procedure: real? obj
 -- C Function: scm_real_p (obj)
     Return `#t' if OBJ is a real number, else `#f'.  Note that the
     sets of integer and rational values form subsets of the set of
     real numbers, so the predicate will also be fulfilled if OBJ is an
     integer number or a rational number.

 -- Scheme Procedure: rational? x
 -- C Function: scm_real_p (x)
     Return `#t' if X is a rational number, `#f' otherwise.  Note that
     the set of integer values forms a subset of the set of rational
     numbers, i. e. the predicate will also be fulfilled if X is an
     integer number.  Real numbers will also satisfy this predicate,
     because of their limited precision.


File: guile.info,  Node: Complex Numbers,  Next: Exactness,  Prev: Reals and Rationals,  Up: Numbers

21.2.4 Complex Numbers
----------------------

Complex numbers are the set of numbers that describe all possible points
in a two-dimensional space.  The two coordinates of a particular point
in this space are known as the "real" and "imaginary" parts of the
complex number that describes that point.

   In Guile, complex numbers are written in rectangular form as the sum
of their real and imaginary parts, using the symbol `i' to indicate the
imaginary part.

     3+4i
     =>
     3.0+4.0i

     (* 3-8i 2.3+0.3i)
     =>
     9.3-17.5i

   Guile represents a complex number as a pair of numbers both of which
are real, so the real and imaginary parts of a complex number have the
same properties of inexactness and limited precision as single real
numbers.

 -- Scheme Procedure: complex? x
 -- C Function: scm_number_p (x)
     Return `#t' if X is a complex number, `#f' otherwise.  Note that
     the sets of real, rational and integer values form subsets of the
     set of complex numbers, i. e. the predicate will also be fulfilled
     if X is a real, rational or integer number.


File: guile.info,  Node: Exactness,  Next: Number Syntax,  Prev: Complex Numbers,  Up: Numbers

21.2.5 Exact and Inexact Numbers
--------------------------------

R5RS requires that a calculation involving inexact numbers always
produces an inexact result.  To meet this requirement, Guile
distinguishes between an exact integer value such as `5' and the
corresponding inexact real value which, to the limited precision
available, has no fractional part, and is printed as `5.0'.  Guile will
only convert the latter value to the former when forced to do so by an
invocation of the `inexact->exact' procedure.

 -- Scheme Procedure: exact? x
 -- C Function: scm_exact_p (x)
     Return `#t' if X is an exact number, `#f' otherwise.

 -- Scheme Procedure: inexact? x
 -- C Function: scm_inexact_p (x)
     Return `#t' if X is an inexact number, `#f' else.

 -- Scheme Procedure: inexact->exact z
 -- C Function: scm_inexact_to_exact (z)
     Return an exact number that is numerically closest to Z.

 -- Scheme Procedure: exact->inexact z
     Convert the number Z to its inexact representation.


File: guile.info,  Node: Number Syntax,  Next: Integer Operations,  Prev: Exactness,  Up: Numbers

21.2.6 Read Syntax for Numerical Data
-------------------------------------

The read syntax for integers is a string of digits, optionally preceded
by a minus or plus character, a code indicating the base in which the
integer is encoded, and a code indicating whether the number is exact
or inexact.  The supported base codes are:

   * `#b', `#B' -- the integer is written in binary (base 2)

   * `#o', `#O' -- the integer is written in octal (base 8)

   * `#d', `#D' -- the integer is written in decimal (base 10)

   * `#x', `#X' -- the integer is written in hexadecimal (base 16).

   If the base code is omitted, the integer is assumed to be decimal.
The following examples show how these base codes are used.

     -13
     =>
     -13

     #d-13
     =>
     -13

     #x-13
     =>
     -19

     #b+1101
     =>
     13

     #o377
     =>
     255

   The codes for indicating exactness (which can, incidentally, be
applied to all numerical values) are:

   * `#e', `#E' -- the number is exact

   * `#i', `#I' -- the number is inexact.

   If the exactness indicator is omitted, the integer is assumed to be
exact, since Guile's internal representation for integers is always
exact.  Real numbers have limited precision similar to the precision of
the `double' type in C.  A consequence of the limited precision is that
all real numbers in Guile are also rational, since any number R with a
limited number of decimal places, say N, can be made into an integer by
multiplying by 10^N.


File: guile.info,  Node: Integer Operations,  Next: Comparison,  Prev: Number Syntax,  Up: Numbers

21.2.7 Operations on Integer Values
-----------------------------------

 -- Scheme Procedure: odd? n
 -- C Function: scm_odd_p (n)
     Return `#t' if N is an odd number, `#f' otherwise.

 -- Scheme Procedure: even? n
 -- C Function: scm_even_p (n)
     Return `#t' if N is an even number, `#f' otherwise.

 -- Scheme Procedure: quotient
     Return the quotient of the numbers X and Y.

 -- Scheme Procedure: remainder
     Return the remainder of the numbers X and Y.
          (remainder 13 4) => 1
          (remainder -13 4) => -1

 -- Scheme Procedure: modulo
     Return the modulo of the numbers X and Y.
          (modulo 13 4) => 1
          (modulo -13 4) => 3

 -- Scheme Procedure: gcd
     Return the greatest common divisor of all arguments.  If called
     without arguments, 0 is returned.

 -- Scheme Procedure: lcm
     Return the least common multiple of the arguments.  If called
     without arguments, 1 is returned.


File: guile.info,  Node: Comparison,  Next: Conversion,  Prev: Integer Operations,  Up: Numbers

21.2.8 Comparison Predicates
----------------------------

 -- Scheme Procedure: =
     Return `#t' if all parameters are numerically equal.

 -- Scheme Procedure: <
     Return `#t' if the list of parameters is monotonically increasing.

 -- Scheme Procedure: >
     Return `#t' if the list of parameters is monotonically decreasing.

 -- Scheme Procedure: <=
     Return `#t' if the list of parameters is monotonically
     non-decreasing.

 -- Scheme Procedure: >=
     Return `#t' if the list of parameters is monotonically
     non-increasing.

 -- Scheme Procedure: zero?
     Return `#t' if Z is an exact or inexact number equal to zero.

 -- Scheme Procedure: positive?
     Return `#t' if X is an exact or inexact number greater than zero.

 -- Scheme Procedure: negative?
     Return `#t' if X is an exact or inexact number less than zero.


File: guile.info,  Node: Conversion,  Next: Complex,  Prev: Comparison,  Up: Numbers

21.2.9 Converting Numbers To and From Strings
---------------------------------------------

 -- Scheme Procedure: number->string n [radix]
 -- C Function: scm_number_to_string (n, radix)
     Return a string holding the external representation of the number
     N in the given RADIX.  If N is inexact, a radix of 10 will be used.

 -- Scheme Procedure: string->number string [radix]
 -- C Function: scm_string_to_number (string, radix)
     Return a number of the maximally precise representation expressed
     by the given STRING. RADIX must be an exact integer, either 2, 8,
     10, or 16. If supplied, RADIX is a default radix that may be
     overridden by an explicit radix prefix in STRING (e.g. "#o177").
     If RADIX is not supplied, then the default radix is 10. If string
     is not a syntactically valid notation for a number, then
     `string->number' returns `#f'.


File: guile.info,  Node: Complex,  Next: Arithmetic,  Prev: Conversion,  Up: Numbers

21.2.10 Complex Number Operations
---------------------------------

 -- Scheme Procedure: make-rectangular real imaginary
 -- C Function: scm_make_rectangular (real, imaginary)
     Return a complex number constructed of the given REAL and
     IMAGINARY parts.

 -- Scheme Procedure: make-polar x y
 -- C Function: scm_make_polar (x, y)
     Return the complex number X * e^(i * Y).

 -- Scheme Procedure: real-part
     Return the real part of the number Z.

 -- Scheme Procedure: imag-part
     Return the imaginary part of the number Z.

 -- Scheme Procedure: magnitude
     Return the magnitude of the number Z. This is the same as `abs'
     for real arguments, but also allows complex numbers.

 -- Scheme Procedure: angle
     Return the angle of the complex number Z.


File: guile.info,  Node: Arithmetic,  Next: Scientific,  Prev: Complex,  Up: Numbers

21.2.11 Arithmetic Functions
----------------------------

 -- Scheme Procedure: + z1 ...
     Return the sum of all parameter values.  Return 0 if called
     without any parameters.

 -- Scheme Procedure: - z1 z2 ...
     If called with one argument Z1, -Z1 is returned. Otherwise the sum
     of all but the first argument are subtracted from the first
     argument.

 -- Scheme Procedure: * z1 ...
     Return the product of all arguments.  If called without arguments,
     1 is returned.

 -- Scheme Procedure: / z1 z2 ...
     Divide the first argument by the product of the remaining
     arguments.  If called with one argument Z1, 1/Z1 is returned.

 -- Scheme Procedure: abs x
 -- C Function: scm_abs (x)
     Return the absolute value of X.

     X must be a number with zero imaginary part.  To calculate the
     magnitude of a complex number, use `magnitude' instead.

 -- Scheme Procedure: max x1 x2 ...
     Return the maximum of all parameter values.

 -- Scheme Procedure: min x1 x2 ...
     Return the minimum of all parameter values.

 -- Scheme Procedure: truncate
     Round the inexact number X towards zero.

 -- Scheme Procedure: round x
     Round the inexact number X to the nearest integer.  When exactly
     halfway between two integers, round to the even one.

 -- Scheme Procedure: floor x
     Round the number X towards minus infinity.

 -- Scheme Procedure: ceiling x
     Round the number X towards infinity.

   For the `truncate' and `round' procedures, the Guile library exports
equivalent C functions, but taking and returning arguments of type
`double' rather than the usual `SCM'.

 -- C Function: double scm_truncate (double x)
 -- C Function: double scm_round (double x)

   For `floor' and `ceiling', the equivalent C functions are `floor'
and `ceil' from the standard mathematics library (which also take and
return `double' arguments).


File: guile.info,  Node: Scientific,  Next: Primitive Numerics,  Prev: Arithmetic,  Up: Numbers

21.2.12 Scientific Functions
----------------------------

The following procedures accept any kind of number as arguments,
including complex numbers.

 -- Scheme Procedure: sqrt z
     Return the square root of Z.

 -- Scheme Procedure: expt z1 z2
     Return Z1 raised to the power of Z2.

 -- Scheme Procedure: sin z
     Return the sine of Z.

 -- Scheme Procedure: cos z
     Return the cosine of Z.

 -- Scheme Procedure: tan z
     Return the tangent of Z.

 -- Scheme Procedure: asin z
     Return the arcsine of Z.

 -- Scheme Procedure: acos z
     Return the arccosine of Z.

 -- Scheme Procedure: atan z
     Return the arctangent of Z.

 -- Scheme Procedure: exp z
     Return e to the power of Z, where e is the base of natural
     logarithms (2.71828...).

 -- Scheme Procedure: log z
     Return the natural logarithm of Z.

 -- Scheme Procedure: log10 z
     Return the base 10 logarithm of Z.

 -- Scheme Procedure: sinh z
     Return the hyperbolic sine of Z.

 -- Scheme Procedure: cosh z
     Return the hyperbolic cosine of Z.

 -- Scheme Procedure: tanh z
     Return the hyperbolic tangent of Z.

 -- Scheme Procedure: asinh z
     Return the hyperbolic arcsine of Z.

 -- Scheme Procedure: acosh z
     Return the hyperbolic arccosine of Z.

 -- Scheme Procedure: atanh z
     Return the hyperbolic arctangent of Z.


File: guile.info,  Node: Primitive Numerics,  Next: Bitwise Operations,  Prev: Scientific,  Up: Numbers

21.2.13 Primitive Numeric Functions
-----------------------------------

Many of Guile's numeric procedures which accept any kind of numbers as
arguments, including complex numbers, are implemented as Scheme
procedures that use the following real number-based primitives.  These
primitives signal an error if they are called with complex arguments.

 -- Scheme Procedure: $abs x
     Return the absolute value of X.

 -- Scheme Procedure: $sqrt x
     Return the square root of X.

 -- Scheme Procedure: $expt x y
 -- C Function: scm_sys_expt (x, y)
     Return X raised to the power of Y. This procedure does not accept
     complex arguments.

 -- Scheme Procedure: $sin x
     Return the sine of X.

 -- Scheme Procedure: $cos x
     Return the cosine of X.

 -- Scheme Procedure: $tan x
     Return the tangent of X.

 -- Scheme Procedure: $asin x
     Return the arcsine of X.

 -- Scheme Procedure: $acos x
     Return the arccosine of X.

 -- Scheme Procedure: $atan x
     Return the arctangent of X in the range -PI/2 to PI/2.

 -- Scheme Procedure: $atan2 x y
 -- C Function: scm_sys_atan2 (x, y)
     Return the arc tangent of the two arguments X and Y. This is
     similar to calculating the arc tangent of X / Y, except that the
     signs of both arguments are used to determine the quadrant of the
     result. This procedure does not accept complex arguments.

 -- Scheme Procedure: $exp x
     Return e to the power of X, where e is the base of natural
     logarithms (2.71828...).

 -- Scheme Procedure: $log x
     Return the natural logarithm of X.

 -- Scheme Procedure: $sinh x
     Return the hyperbolic sine of X.

 -- Scheme Procedure: $cosh x
     Return the hyperbolic cosine of X.

 -- Scheme Procedure: $tanh x
     Return the hyperbolic tangent of X.

 -- Scheme Procedure: $asinh x
     Return the hyperbolic arcsine of X.

 -- Scheme Procedure: $acosh x
     Return the hyperbolic arccosine of X.

 -- Scheme Procedure: $atanh x
     Return the hyperbolic arctangent of X.

   For the hyperbolic arc-functions, the Guile library exports C
functions corresponding to these Scheme procedures, but taking and
returning arguments of type `double' rather than the usual `SCM'.

 -- C Function: double scm_asinh (double x)
 -- C Function: double scm_acosh (double x)
 -- C Function: double scm_atanh (double x)
     Return the hyperbolic arcsine, arccosine or arctangent of X
     respectively.

   For all the other Scheme procedures above, except `expt' and `atan2'
(whose entries specifically mention an equivalent C function), the
equivalent C functions are those provided by the standard mathematics
library.  The mapping is as follows.

     Scheme Procedure   C Function
     `$abs'             `fabs'
     `$sqrt'            `sqrt'
     `$sin'             `sin'
     `$cos'             `cos'
     `$tan'             `tan'
     `$asin'            `asin'
     `$acos'            `acos'
     `$atan'            `atan'
     `$exp'             `exp'
     `$log'             `log'
     `$sinh'            `sinh'
     `$cosh'            `cosh'
     `$tanh'            `tanh'

Naturally, these C functions expect and return `double' arguments.


File: guile.info,  Node: Bitwise Operations,  Next: Random,  Prev: Primitive Numerics,  Up: Numbers

21.2.14 Bitwise Operations
--------------------------

 -- Scheme Procedure: logand n1 n2
     Return the bitwise AND of the integer arguments.

          (logand) => -1
          (logand 7) => 7
          (logand #b111 #b011 #b001) => 1

 -- Scheme Procedure: logior n1 n2
     Return the bitwise OR of the integer arguments.

          (logior) => 0
          (logior 7) => 7
          (logior #b000 #b001 #b011) => 3

 -- Scheme Procedure: logxor n1 n2
     Return the bitwise XOR of the integer arguments.  A bit is set in
     the result if it is set in an odd number of arguments.
          (logxor) => 0
          (logxor 7) => 7
          (logxor #b000 #b001 #b011) => 2
          (logxor #b000 #b001 #b011 #b011) => 1

 -- Scheme Procedure: lognot n
 -- C Function: scm_lognot (n)
     Return the integer which is the ones-complement of the integer
     argument, ie. each 0 bit is changed to 1 and each 1 bit to 0.

          (number->string (lognot #b10000000) 2)
             => "-10000001"
          (number->string (lognot #b0) 2)
             => "-1"

 -- Scheme Procedure: logtest j k
 -- C Function: scm_logtest (j, k)
          (logtest j k) == (not (zero? (logand j k)))

          (logtest #b0100 #b1011) => #f
          (logtest #b0100 #b0111) => #t

 -- Scheme Procedure: logbit? index j
 -- C Function: scm_logbit_p (index, j)
          (logbit? index j) == (logtest (integer-expt 2 index) j)

          (logbit? 0 #b1101) => #t
          (logbit? 1 #b1101) => #f
          (logbit? 2 #b1101) => #t
          (logbit? 3 #b1101) => #t
          (logbit? 4 #b1101) => #f

 -- Scheme Procedure: ash n cnt
 -- C Function: scm_ash (n, cnt)
     The function ash performs an arithmetic shift left by CNT bits (or
     shift right, if CNT is negative).  'Arithmetic' means, that the
     function does not guarantee to keep the bit structure of N, but
     rather guarantees that the result will always be rounded towards
     minus infinity.  Therefore, the results of ash and a corresponding
     bitwise shift will differ if N is negative.

     Formally, the function returns an integer equivalent to
     `(inexact->exact (floor (* N (expt 2 CNT))))'.

          (number->string (ash #b1 3) 2)     => "1000"
          (number->string (ash #b1010 -1) 2) => "101"

 -- Scheme Procedure: logcount n
 -- C Function: scm_logcount (n)
     Return the number of bits in integer N.  If integer is positive,
     the 1-bits in its binary representation are counted.  If negative,
     the 0-bits in its two's-complement binary representation are
     counted.  If 0, 0 is returned.

          (logcount #b10101010)
             => 4
          (logcount 0)
             => 0
          (logcount -2)
             => 1

 -- Scheme Procedure: integer-length n
 -- C Function: scm_integer_length (n)
     Return the number of bits necessary to represent N.

          (integer-length #b10101010)
             => 8
          (integer-length 0)
             => 0
          (integer-length #b1111)
             => 4

 -- Scheme Procedure: integer-expt n k
 -- C Function: scm_integer_expt (n, k)
     Return N raised to the non-negative integer exponent K.

          (integer-expt 2 5)
             => 32
          (integer-expt -3 3)
             => -27

 -- Scheme Procedure: bit-extract n start end
 -- C Function: scm_bit_extract (n, start, end)
     Return the integer composed of the START (inclusive) through END
     (exclusive) bits of N.  The STARTth bit becomes the 0-th bit in
     the result.

          (number->string (bit-extract #b1101101010 0 4) 2)
             => "1010"
          (number->string (bit-extract #b1101101010 4 9) 2)
             => "10110"


File: guile.info,  Node: Random,  Prev: Bitwise Operations,  Up: Numbers

21.2.15 Random Number Generation
--------------------------------

 -- Scheme Procedure: copy-random-state [state]
 -- C Function: scm_copy_random_state (state)
     Return a copy of the random state STATE.

 -- Scheme Procedure: random n [state]
 -- C Function: scm_random (n, state)
     Return a number in [0, N).

     Accepts a positive integer or real n and returns a number of the
     same type between zero (inclusive) and N (exclusive). The values
     returned have a uniform distribution.

     The optional argument STATE must be of the type produced by
     `seed->random-state'. It defaults to the value of the variable
     `*random-state*'. This object is used to maintain the state of the
     pseudo-random-number generator and is altered as a side effect of
     the random operation.

 -- Scheme Procedure: random:exp [state]
 -- C Function: scm_random_exp (state)
     Return an inexact real in an exponential distribution with mean 1.
     For an exponential distribution with mean u use (* u
     (random:exp)).

 -- Scheme Procedure: random:hollow-sphere! v [state]
 -- C Function: scm_random_hollow_sphere_x (v, state)
     Fills vect with inexact real random numbers the sum of whose
     squares is equal to 1.0.  Thinking of vect as coordinates in space
     of dimension n = (vector-length vect), the coordinates are
     uniformly distributed over the surface of the unit n-sphere.

 -- Scheme Procedure: random:normal [state]
 -- C Function: scm_random_normal (state)
     Return an inexact real in a normal distribution.  The distribution
     used has mean 0 and standard deviation 1.  For a normal
     distribution with mean m and standard deviation d use `(+ m (* d
     (random:normal)))'.

 -- Scheme Procedure: random:normal-vector! v [state]
 -- C Function: scm_random_normal_vector_x (v, state)
     Fills vect with inexact real random numbers that are independent
     and standard normally distributed (i.e., with mean 0 and variance
     1).

 -- Scheme Procedure: random:solid-sphere! v [state]
 -- C Function: scm_random_solid_sphere_x (v, state)
     Fills vect with inexact real random numbers the sum of whose
     squares is less than 1.0.  Thinking of vect as coordinates in
     space of dimension n = (vector-length vect), the coordinates are
     uniformly distributed within the unit n-sphere.  The sum of the
     squares of the numbers is returned.

 -- Scheme Procedure: random:uniform [state]
 -- C Function: scm_random_uniform (state)
     Return a uniformly distributed inexact real random number in [0,1).

 -- Scheme Procedure: seed->random-state seed
 -- C Function: scm_seed_to_random_state (seed)
     Return a new random state using SEED.


File: guile.info,  Node: Characters,  Next: Strings,  Prev: Numbers,  Up: Simple Data Types

21.3 Characters
===============

Most of the characters in the ASCII character set may be referred to by
name: for example, `#\tab', `#\esc', `#\stx', and so on.  The following
table describes the ASCII names for each character.

0 = `#\nul'        1 = `#\soh'        2 = `#\stx'        3 = `#\etx'
4 = `#\eot'        5 = `#\enq'        6 = `#\ack'        7 = `#\bel'
8 = `#\bs'         9 = `#\ht'         10 = `#\nl'        11 = `#\vt'
12 = `#\np'        13 = `#\cr'        14 = `#\so'        15 = `#\si'
16 = `#\dle'       17 = `#\dc1'       18 = `#\dc2'       19 = `#\dc3'
20 = `#\dc4'       21 = `#\nak'       22 = `#\syn'       23 = `#\etb'
24 = `#\can'       25 = `#\em'        26 = `#\sub'       27 = `#\esc'
28 = `#\fs'        29 = `#\gs'        30 = `#\rs'        31 = `#\us'
32 = `#\sp'                                              

   The `delete' character (octal 177) may be referred to with the name
`#\del'.

   Several characters have more than one name:

   * `#\space', `#\sp'

   * `#\newline', `#\nl'

   * `#\tab', `#\ht'

   * `#\backspace', `#\bs'

   * `#\return', `#\cr'

   * `#\page', `#\np'

   * `#\null', `#\nul'

 -- Scheme Procedure: char? x
 -- C Function: scm_char_p (x)
     Return `#t' iff X is a character, else `#f'.

 -- Scheme Procedure: char=? x y
     Return `#t' iff X is the same character as Y, else `#f'.

 -- Scheme Procedure: char<? x y
     Return `#t' iff X is less than Y in the ASCII sequence, else `#f'.

 -- Scheme Procedure: char<=? x y
     Return `#t' iff X is less than or equal to Y in the ASCII
     sequence, else `#f'.

 -- Scheme Procedure: char>? x y
     Return `#t' iff X is greater than Y in the ASCII sequence, else
     `#f'.

 -- Scheme Procedure: char>=? x y
     Return `#t' iff X is greater than or equal to Y in the ASCII
     sequence, else `#f'.

 -- Scheme Procedure: char-ci=? x y
     Return `#t' iff X is the same character as Y ignoring case, else
     `#f'.

 -- Scheme Procedure: char-ci<? x y
     Return `#t' iff X is less than Y in the ASCII sequence ignoring
     case, else `#f'.

 -- Scheme Procedure: char-ci<=? x y
     Return `#t' iff X is less than or equal to Y in the ASCII sequence
     ignoring case, else `#f'.

 -- Scheme Procedure: char-ci>? x y
     Return `#t' iff X is greater than Y in the ASCII sequence ignoring
     case, else `#f'.

 -- Scheme Procedure: char-ci>=? x y
     Return `#t' iff X is greater than or equal to Y in the ASCII
     sequence ignoring case, else `#f'.

 -- Scheme Procedure: char-alphabetic? chr
 -- C Function: scm_char_alphabetic_p (chr)
     Return `#t' iff CHR is alphabetic, else `#f'.  Alphabetic means
     the same thing as the isalpha C library function.

 -- Scheme Procedure: char-numeric? chr
 -- C Function: scm_char_numeric_p (chr)
     Return `#t' iff CHR is numeric, else `#f'.  Numeric means the same
     thing as the isdigit C library function.

 -- Scheme Procedure: char-whitespace? chr
 -- C Function: scm_char_whitespace_p (chr)
     Return `#t' iff CHR is whitespace, else `#f'.  Whitespace means
     the same thing as the isspace C library function.

 -- Scheme Procedure: char-upper-case? chr
 -- C Function: scm_char_upper_case_p (chr)
     Return `#t' iff CHR is uppercase, else `#f'.  Uppercase means the
     same thing as the isupper C library function.

 -- Scheme Procedure: char-lower-case? chr
 -- C Function: scm_char_lower_case_p (chr)
     Return `#t' iff CHR is lowercase, else `#f'.  Lowercase means the
     same thing as the islower C library function.

 -- Scheme Procedure: char-is-both? chr
 -- C Function: scm_char_is_both_p (chr)
     Return `#t' iff CHR is either uppercase or lowercase, else `#f'.
     Uppercase and lowercase are as defined by the isupper and islower
     C library functions.

 -- Scheme Procedure: char->integer chr
 -- C Function: scm_char_to_integer (chr)
     Return the number corresponding to ordinal position of CHR in the
     ASCII sequence.

 -- Scheme Procedure: integer->char n
 -- C Function: scm_integer_to_char (n)
     Return the character at position N in the ASCII sequence.

 -- Scheme Procedure: char-upcase chr
 -- C Function: scm_char_upcase (chr)
     Return the uppercase character version of CHR.

 -- Scheme Procedure: char-downcase chr
 -- C Function: scm_char_downcase (chr)
     Return the lowercase character version of CHR.


File: guile.info,  Node: Strings,  Next: Regular Expressions,  Prev: Characters,  Up: Simple Data Types

21.4 Strings
============

Strings are fixed-length sequences of characters.  They can be created
by calling constructor procedures, but they can also literally get
entered at the REPL or in Scheme source files.

   Guile provides a rich set of string processing procedures, because
text handling is very important when Guile is used as a scripting
language.

   Strings always carry the information about how many characters they
are composed of with them, so there is no special end-of-string
character, like in C.  That means that Scheme strings can contain any
character, even the NUL character `'\0''.  But note: Since most
operating system calls dealing with strings (such as for file
operations) expect strings to be zero-terminated, they might do
unexpected things when called with string containing unusual characters.

* Menu:

* String Syntax::               Read syntax for strings.
* String Predicates::           Testing strings for certain properties.
* String Constructors::         Creating new string objects.
* List/String Conversion::      Converting from/to lists of characters.
* String Selection::            Select portions from strings.
* String Modification::         Modify parts or whole strings.
* String Comparison::           Lexicographic ordering predicates.
* String Searching::            Searching in strings.
* Alphabetic Case Mapping::     Convert the alphabetic case of strings.
* Appending Strings::           Appending strings to form a new string.


File: guile.info,  Node: String Syntax,  Next: String Predicates,  Up: Strings

21.4.1 String Read Syntax
-------------------------

The read syntax for strings is an arbitrarily long sequence of
characters enclosed in double quotes (`"'). (1)  If you want to insert
a double quote character into a string literal, it must be prefixed
with a backslash `\' character (called an "escape character").

   The following are examples of string literals:

     "foo"
     "bar plonk"
     "Hello World"
     "\"Hi\", he said."

   ---------- Footnotes ----------

   (1) Actually, the current implementation restricts strings to a
length of 2^24 characters.


File: guile.info,  Node: String Predicates,  Next: String Constructors,  Prev: String Syntax,  Up: Strings

21.4.2 String Predicates
------------------------

The following procedures can be used to check whether a given string
fulfills some specified property.

 -- Scheme Procedure: string? obj
 -- C Function: scm_string_p (obj)
     Return `#t' if OBJ is a string, else `#f'.

 -- Scheme Procedure: string-null? str
 -- C Function: scm_string_null_p (str)
     Return `#t' if STR's length is zero, and `#f' otherwise.
          (string-null? "")  => #t
          y                    => "foo"
          (string-null? y)     => #f


File: guile.info,  Node: String Constructors,  Next: List/String Conversion,  Prev: String Predicates,  Up: Strings

21.4.3 String Constructors
--------------------------

The string constructor procedures create new string objects, possibly
initializing them with some specified character data.

 -- Scheme Procedure: string . chrs
 -- Scheme Procedure: list->string chrs
 -- C Function: scm_string (chrs)
     Return a newly allocated string composed of the arguments, CHRS.

 -- Scheme Procedure: make-string k [chr]
 -- C Function: scm_make_string (k, chr)
     Return a newly allocated string of length K.  If CHR is given,
     then all elements of the string are initialized to CHR, otherwise
     the contents of the STRING are unspecified.


File: guile.info,  Node: List/String Conversion,  Next: String Selection,  Prev: String Constructors,  Up: Strings

21.4.4 List/String conversion
-----------------------------

When processing strings, it is often convenient to first convert them
into a list representation by using the procedure `string->list', work
with the resulting list, and then convert it back into a string.  These
procedures are useful for similar tasks.

 -- Scheme Procedure: string->list str
 -- C Function: scm_string_to_list (str)
     Return a newly allocated list of the characters that make up the
     given string STR. `string->list' and `list->string' are inverses
     as far as `equal?' is concerned.

 -- Scheme Procedure: string-split str chr
 -- C Function: scm_string_split (str, chr)
     Split the string STR into the a list of the substrings delimited
     by appearances of the character CHR.  Note that an empty substring
     between separator characters will result in an empty string in the
     result list.

          (string-split "root:x:0:0:root:/root:/bin/bash" #\:)
          =>
          ("root" "x" "0" "0" "root" "/root" "/bin/bash")

          (string-split "::" #\:)
          =>
          ("" "" "")

          (string-split "" #\:)
          =>
          ("")


File: guile.info,  Node: String Selection,  Next: String Modification,  Prev: List/String Conversion,  Up: Strings

21.4.5 String Selection
-----------------------

Portions of strings can be extracted by these procedures.  `string-ref'
delivers individual characters whereas `substring' can be used to
extract substrings from longer strings.

 -- Scheme Procedure: string-length string
 -- C Function: scm_string_length (string)
     Return the number of characters in STRING.

 -- Scheme Procedure: string-ref str k
 -- C Function: scm_string_ref (str, k)
     Return character K of STR using zero-origin indexing. K must be a
     valid index of STR.

 -- Scheme Procedure: string-copy str
 -- C Function: scm_string_copy (str)
     Return a newly allocated copy of the given STRING.

 -- Scheme Procedure: substring str start [end]
 -- C Function: scm_substring (str, start, end)
     Return a newly allocated string formed from the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).


File: guile.info,  Node: String Modification,  Next: String Comparison,  Prev: String Selection,  Up: Strings

21.4.6 String Modification
--------------------------

These procedures are for modifying strings in-place.  This means that
the result of the operation is not a new string; instead, the original
string's memory representation is modified.

 -- Scheme Procedure: string-set! str k chr
 -- C Function: scm_string_set_x (str, k, chr)
     Store CHR in element K of STR and return an unspecified value. K
     must be a valid index of STR.

 -- Scheme Procedure: string-fill! str chr
 -- C Function: scm_string_fill_x (str, chr)
     Store CHAR in every element of the given STRING and return an
     unspecified value.

 -- Scheme Procedure: substring-fill! str start end fill
 -- C Function: scm_substring_fill_x (str, start, end, fill)
     Change every character in STR between START and END to FILL.

          (define y "abcdefg")
          (substring-fill! y 1 3 #\r)
          y
          => "arrdefg"

 -- Scheme Procedure: substring-move! str1 start1 end1 str2 start2
 -- C Function: scm_substring_move_x (str1, start1, end1, str2, start2)
     Copy the substring of STR1 bounded by START1 and END1 into STR2
     beginning at position START2.  STR1 and STR2 can be the same
     string.


File: guile.info,  Node: String Comparison,  Next: String Searching,  Prev: String Modification,  Up: Strings

21.4.7 String Comparison
------------------------

The procedures in this section are similar to the character ordering
predicates (*note Characters::), but are defined on character sequences.
They all return `#t' on success and `#f' on failure.  The predicates
ending in `-ci' ignore the character case when comparing strings.

 -- Scheme Procedure: string=? s1 s2
     Lexicographic equality predicate; return `#t' if the two strings
     are the same length and contain the same characters in the same
     positions, otherwise return `#f'.

     The procedure `string-ci=?' treats upper and lower case letters as
     though they were the same character, but `string=?' treats upper
     and lower case as distinct characters.

 -- Scheme Procedure: string<? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than S2.

 -- Scheme Procedure: string<=? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than or equal to S2.

 -- Scheme Procedure: string>? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than S2.

 -- Scheme Procedure: string>=? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than or equal to S2.

 -- Scheme Procedure: string-ci=? s1 s2
     Case-insensitive string equality predicate; return `#t' if the two
     strings are the same length and their component characters match
     (ignoring case) at each position; otherwise return `#f'.

 -- Scheme Procedure: string-ci<? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than S2 regardless of case.

 -- Scheme Procedure: string-ci<=? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than or equal to S2 regardless of
     case.

 -- Scheme Procedure: string-ci>? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than S2 regardless of case.

 -- Scheme Procedure: string-ci>=? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than or equal to S2 regardless of
     case.


File: guile.info,  Node: String Searching,  Next: Alphabetic Case Mapping,  Prev: String Comparison,  Up: Strings

21.4.8 String Searching
-----------------------

When searching for the index of a character in a string, these
procedures can be used.

 -- Scheme Procedure: string-index str chr [frm [to]]
 -- C Function: scm_string_index (str, chr, frm, to)
     Return the index of the first occurrence of CHR in STR.  The
     optional integer arguments FRM and TO limit the search to a
     portion of the string.  This procedure essentially implements the
     `index' or `strchr' functions from the C library.

          (string-index "weiner" #\e)
          => 1

          (string-index "weiner" #\e 2)
          => 4

          (string-index "weiner" #\e 2 4)
          => #f

 -- Scheme Procedure: string-rindex str chr [frm [to]]
 -- C Function: scm_string_rindex (str, chr, frm, to)
     Like `string-index', but search from the right of the string
     rather than from the left.  This procedure essentially implements
     the `rindex' or `strrchr' functions from the C library.

          (string-rindex "weiner" #\e)
          => 4

          (string-rindex "weiner" #\e 2 4)
          => #f

          (string-rindex "weiner" #\e 2 5)
          => 4


File: guile.info,  Node: Alphabetic Case Mapping,  Next: Appending Strings,  Prev: String Searching,  Up: Strings

21.4.9 Alphabetic Case Mapping
------------------------------

These are procedures for mapping strings to their upper- or lower-case
equivalents, respectively, or for capitalizing strings.

 -- Scheme Procedure: string-upcase str
 -- C Function: scm_string_upcase (str)
     Return a freshly allocated string containing the characters of STR
     in upper case.

 -- Scheme Procedure: string-upcase! str
 -- C Function: scm_string_upcase_x (str)
     Destructively upcase every character in STR and return STR.
          y                  => "arrdefg"
          (string-upcase! y) => "ARRDEFG"
          y                  => "ARRDEFG"

 -- Scheme Procedure: string-downcase str
 -- C Function: scm_string_downcase (str)
     Return a freshly allocation string containing the characters in
     STR in lower case.

 -- Scheme Procedure: string-downcase! str
 -- C Function: scm_string_downcase_x (str)
     Destructively downcase every character in STR and return STR.
          y                     => "ARRDEFG"
          (string-downcase! y)  => "arrdefg"
          y                     => "arrdefg"

 -- Scheme Procedure: string-capitalize str
 -- C Function: scm_string_capitalize (str)
     Return a freshly allocated string with the characters in STR,
     where the first character of every word is capitalized.

 -- Scheme Procedure: string-capitalize! str
 -- C Function: scm_string_capitalize_x (str)
     Upcase the first character of every word in STR destructively and
     return STR.

          y                      => "hello world"
          (string-capitalize! y) => "Hello World"
          y                      => "Hello World"


File: guile.info,  Node: Appending Strings,  Prev: Alphabetic Case Mapping,  Up: Strings

21.4.10 Appending Strings
-------------------------

The procedure `string-append' appends several strings together to form
a longer result string.

 -- Scheme Procedure: string-append . args
 -- C Function: scm_string_append (args)
     Return a newly allocated string whose characters form the
     concatenation of the given strings, ARGS.

          (let ((h "hello "))
            (string-append h "world"))
          => "hello world"


File: guile.info,  Node: Regular Expressions,  Next: Symbols,  Prev: Strings,  Up: Simple Data Types

21.5 Regular Expressions
========================

A "regular expression" (or "regexp") is a pattern that describes a
whole class of strings.  A full description of regular expressions and
their syntax is beyond the scope of this manual; an introduction can be
found in the Emacs manual (*note Syntax of Regular Expressions:
(emacs)Regexps.), or in many general Unix reference books.

   If your system does not include a POSIX regular expression library,
and you have not linked Guile with a third-party regexp library such as
Rx, these functions will not be available.  You can tell whether your
Guile installation includes regular expression support by checking
whether `(provided? 'regex)' returns true.

   The following regexp and string matching features are provided by the
`(ice-9 regex)' module.  Before using the described functions, you
should load this module by executing `(use-modules (ice-9 regex))'.

* Menu:

* Regexp Functions::            Functions that create and match regexps.
* Match Structures::            Finding what was matched by a regexp.
* Backslash Escapes::           Removing the special meaning of regexp
                                meta-characters.


File: guile.info,  Node: Regexp Functions,  Next: Match Structures,  Up: Regular Expressions

21.5.1 Regexp Functions
-----------------------

By default, Guile supports POSIX extended regular expressions.  That
means that the characters `(', `)', `+' and `?' are special, and must
be escaped if you wish to match the literal characters.

   This regular expression interface was modeled after that implemented
by SCSH, the Scheme Shell.  It is intended to be upwardly compatible
with SCSH regular expressions.

 -- Scheme Procedure: string-match pattern str [start]
     Compile the string PATTERN into a regular expression and compare
     it with STR.  The optional numeric argument START specifies the
     position of STR at which to begin matching.

     `string-match' returns a "match structure" which describes what,
     if anything, was matched by the regular expression.  *Note Match
     Structures::.  If STR does not match PATTERN at all,
     `string-match' returns `#f'.

   Two examples of a match follow.  In the first example, the pattern
matches the four digits in the match string.  In the second, the pattern
matches nothing.

     (string-match "[0-9][0-9][0-9][0-9]" "blah2002")
     => #("blah2002" (4 . 8))

     (string-match "[A-Za-z]" "123456")
     => #f

   Each time `string-match' is called, it must compile its PATTERN
argument into a regular expression structure.  This operation is
expensive, which makes `string-match' inefficient if the same regular
expression is used several times (for example, in a loop).  For better
performance, you can compile a regular expression in advance and then
match strings against the compiled regexp.

 -- Scheme Procedure: make-regexp pat . flags
 -- C Function: scm_make_regexp (pat, flags)
     Compile the regular expression described by PAT, and return the
     compiled regexp structure.  If PAT does not describe a legal
     regular expression, `make-regexp' throws a
     `regular-expression-syntax' error.

     The FLAGS arguments change the behavior of the compiled regular
     expression.  The following flags may be supplied:

    `regexp/icase'
          Consider uppercase and lowercase letters to be the same when
          matching.

    `regexp/newline'
          If a newline appears in the target string, then permit the
          `^' and `$' operators to match immediately after or
          immediately before the newline, respectively.  Also, the `.'
          and `[^...]' operators will never match a newline character.
          The intent of this flag is to treat the target string as a
          buffer containing many lines of text, and the regular
          expression as a pattern that may match a single one of those
          lines.

    `regexp/basic'
          Compile a basic ("obsolete") regexp instead of the extended
          ("modern") regexps that are the default.  Basic regexps do
          not consider `|', `+' or `?' to be special characters, and
          require the `{...}' and `(...)' metacharacters to be
          backslash-escaped (*note Backslash Escapes::).  There are
          several other differences between basic and extended regular
          expressions, but these are the most significant.

    `regexp/extended'
          Compile an extended regular expression rather than a basic
          regexp.  This is the default behavior; this flag will not
          usually be needed.  If a call to `make-regexp' includes both
          `regexp/basic' and `regexp/extended' flags, the one which
          comes last will override the earlier one.

 -- Scheme Procedure: regexp-exec rx str [start [flags]]
 -- C Function: scm_regexp_exec (rx, str, start, flags)
     Match the compiled regular expression RX against `str'.  If the
     optional integer START argument is provided, begin matching from
     that position in the string.  Return a match structure describing
     the results of the match, or `#f' if no match could be found.

     The FLAGS arguments change the matching behavior.  The following
     flags may be supplied:

    `regexp/notbol'
          Operator `^' always fails (unless `regexp/newline' is used).
          Use this when the beginning of the string should not be
          considered the beginning of a line.

    `regexp/noteol'
          Operator `$' always fails (unless `regexp/newline' is used).
          Use this when the end of the string should not be considered
          the end of a line.

     ;; Regexp to match uppercase letters
     (define r (make-regexp "[A-Z]*"))

     ;; Regexp to match letters, ignoring case
     (define ri (make-regexp "[A-Z]*" regexp/icase))

     ;; Search for bob using regexp r
     (match:substring (regexp-exec r "bob"))
     => ""                  ; no match

     ;; Search for bob using regexp ri
     (match:substring (regexp-exec ri "Bob"))
     => "Bob"               ; matched case insensitive

 -- Scheme Procedure: regexp? obj
 -- C Function: scm_regexp_p (obj)
     Return `#t' if OBJ is a compiled regular expression, or `#f'
     otherwise.

   Regular expressions are commonly used to find patterns in one string
and replace them with the contents of another string.

 -- Scheme Procedure: regexp-substitute port match [item...]
     Write to the output port PORT selected contents of the match
     structure MATCH.  Each ITEM specifies what should be written, and
     may be one of the following arguments:

        * A string.  String arguments are written out verbatim.

        * An integer.  The submatch with that number is written.

        * The symbol `pre'.  The portion of the matched string preceding
          the regexp match is written.

        * The symbol `post'.  The portion of the matched string
          following the regexp match is written.

     The PORT argument may be `#f', in which case nothing is written;
     instead, `regexp-substitute' constructs a string from the
     specified ITEMs and returns that.

   The following example takes a regular expression that matches a
standard YYYYMMDD-format date such as `"20020828"'.  The
`regexp-substitute' call returns a string computed from the information
in the match structure, consisting of the fields and text from the
original string reordered and reformatted.

     (define date-regex "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
     (define s "Date 20020429 12am.")
     (define sm (string-match date-regex s))
     (regexp-substitute #f sm 'pre 2 "-" 3 "-" 1 'post " (" 0 ")")
     => "Date 04-29-2002 12am. (20020429)"

 -- Scheme Procedure: regexp-substitute/global port regexp target
          [item...]
     Similar to `regexp-substitute', but can be used to perform global
     substitutions on STR.  Instead of taking a match structure as an
     argument, `regexp-substitute/global' takes two string arguments: a
     REGEXP string describing a regular expression, and a TARGET string
     which should be matched against this regular expression.

     Each ITEM behaves as in REGEXP-SUBSTITUTE, with the following
     exceptions:

        * A function may be supplied.  When this function is called, it
          will be passed one argument: a match structure for a given
          regular expression match.  It should return a string to be
          written out to PORT.

        * The `post' symbol causes `regexp-substitute/global' to recurse
          on the unmatched portion of STR.  This _must_ be supplied in
          order to perform global search-and-replace on STR; if it is
          not present among the ITEMs, then `regexp-substitute/global'
          will return after processing a single match.

   The example above for `regexp-substitute' could be rewritten as
follows to remove the `string-match' stage:

     (define date-regex "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
     (define s "Date 20020429 12am.")
     (regexp-substitute/global #f date-regex s
       'pre 2 "-" 3 "-" 1 'post " (" 0 ")")
     => "Date 04-29-2002 12am. (20020429)"


File: guile.info,  Node: Match Structures,  Next: Backslash Escapes,  Prev: Regexp Functions,  Up: Regular Expressions

21.5.2 Match Structures
-----------------------

A "match structure" is the object returned by `string-match' and
`regexp-exec'.  It describes which portion of a string, if any, matched
the given regular expression.  Match structures include: a reference to
the string that was checked for matches; the starting and ending
positions of the regexp match; and, if the regexp included any
parenthesized subexpressions, the starting and ending positions of each
submatch.

   In each of the regexp match functions described below, the `match'
argument must be a match structure returned by a previous call to
`string-match' or `regexp-exec'.  Most of these functions return some
information about the original target string that was matched against a
regular expression; we will call that string TARGET for easy reference.

 -- Scheme Procedure: regexp-match? obj
     Return `#t' if OBJ is a match structure returned by a previous
     call to `regexp-exec', or `#f' otherwise.

 -- Scheme Procedure: match:substring match [n]
     Return the portion of TARGET matched by subexpression number N.
     Submatch 0 (the default) represents the entire regexp match.  If
     the regular expression as a whole matched, but the subexpression
     number N did not match, return `#f'.

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:substring s)
     => "2002"

     ;; match starting at offset 6 in the string
     (match:substring
       (string-match "[0-9][0-9][0-9][0-9]" "blah987654" 6))
     => "7654"

 -- Scheme Procedure: match:start match [n]
     Return the starting position of submatch number N.

   In the following example, the result is 4, since the match starts at
character index 4:

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:start s)
     => 4

 -- Scheme Procedure: match:end match [n]
     Return the ending position of submatch number N.

   In the following example, the result is 8, since the match runs
between characters 4 and 8 (i.e. the "2002").

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:end s)
     => 8

 -- Scheme Procedure: match:prefix match
     Return the unmatched portion of TARGET preceding the regexp match.

          (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
          (match:prefix s)
          => "blah"

 -- Scheme Procedure: match:suffix match
     Return the unmatched portion of TARGET following the regexp match.

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:suffix s)
     => "foo"

 -- Scheme Procedure: match:count match
     Return the number of parenthesized subexpressions from MATCH.
     Note that the entire regular expression match itself counts as a
     subexpression, and failed submatches are included in the count.

 -- Scheme Procedure: match:string match
     Return the original TARGET string.

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:string s)
     => "blah2002foo"


File: guile.info,  Node: Backslash Escapes,  Prev: Match Structures,  Up: Regular Expressions

21.5.3 Backslash Escapes
------------------------

Sometimes you will want a regexp to match characters like `*' or `$'
exactly.  For example, to check whether a particular string represents
a menu entry from an Info node, it would be useful to match it against
a regexp like `^* [^:]*::'.  However, this won't work; because the
asterisk is a metacharacter, it won't match the `*' at the beginning of
the string.  In this case, we want to make the first asterisk un-magic.

   You can do this by preceding the metacharacter with a backslash
character `\'.  (This is also called "quoting" the metacharacter, and
is known as a "backslash escape".)  When Guile sees a backslash in a
regular expression, it considers the following glyph to be an ordinary
character, no matter what special meaning it would ordinarily have.
Therefore, we can make the above example work by changing the regexp to
`^\* [^:]*::'.  The `\*' sequence tells the regular expression engine
to match only a single asterisk in the target string.

   Since the backslash is itself a metacharacter, you may force a
regexp to match a backslash in the target string by preceding the
backslash with itself.  For example, to find variable references in a
TeX program, you might want to find occurrences of the string `\let\'
followed by any number of alphabetic characters.  The regular expression
`\\let\\[A-Za-z]*' would do this: the double backslashes in the regexp
each match a single backslash in the target string.

 -- Scheme Procedure: regexp-quote str
     Quote each special character found in STR with a backslash, and
     return the resulting string.

   *Very important:* Using backslash escapes in Guile source code (as
in Emacs Lisp or C) can be tricky, because the backslash character has
special meaning for the Guile reader.  For example, if Guile encounters
the character sequence `\n' in the middle of a string while processing
Scheme code, it replaces those characters with a newline character.
Similarly, the character sequence `\t' is replaced by a horizontal tab.
Several of these "escape sequences" are processed by the Guile reader
before your code is executed.  Unrecognized escape sequences are
ignored: if the characters `\*' appear in a string, they will be
translated to the single character `*'.

   This translation is obviously undesirable for regular expressions,
since we want to be able to include backslashes in a string in order to
escape regexp metacharacters.  Therefore, to make sure that a backslash
is preserved in a string in your Guile program, you must use _two_
consecutive backslashes:

     (define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))

   The string in this example is preprocessed by the Guile reader before
any code is executed.  The resulting argument to `make-regexp' is the
string `^\* [^:]*', which is what we really want.

   This also means that in order to write a regular expression that
matches a single backslash character, the regular expression string in
the source code must include _four_ backslashes.  Each consecutive pair
of backslashes gets translated by the Guile reader to a single
backslash, and the resulting double-backslash is interpreted by the
regexp engine as matching a single backslash character.  Hence:

     (define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))

   The reason for the unwieldiness of this syntax is historical.  Both
regular expression pattern matchers and Unix string processing systems
have traditionally used backslashes with the special meanings described
above.  The POSIX regular expression specification and ANSI C standard
both require these semantics.  Attempting to abandon either convention
would cause other kinds of compatibility problems, possibly more severe
ones.  Therefore, without extending the Scheme reader to support
strings with different quoting conventions (an ungainly and confusing
extension when implemented in other languages), we must adhere to this
cumbersome escape syntax.


File: guile.info,  Node: Symbols,  Next: Keywords,  Prev: Regular Expressions,  Up: Simple Data Types

21.6 Symbols
============

Symbols in Scheme are widely used in three ways: as items of discrete
data, as lookup keys for alists and hash tables, and to denote variable
references.

   A "symbol" is similar to a string in that it is defined by a
sequence of characters.  The sequence of characters is known as the
symbol's "name".  In the usual case -- that is, where the symbol's name
doesn't include any characters that could be confused with other
elements of Scheme syntax -- a symbol is written in a Scheme program by
writing the sequence of characters that make up the name, _without_ any
quotation marks or other special syntax.  For example, the symbol whose
name is "multiply-by-2" is written, simply:

     multiply-by-2

   Notice how this differs from a _string_ with contents
"multiply-by-2", which is written with double quotation marks, like
this:

     "multiply-by-2"

   Looking beyond how they are written, symbols are different from
strings in two important respects.

   The first important difference is uniqueness.  If the same-looking
string is read twice from two different places in a program, the result
is two _different_ string objects whose contents just happen to be the
same.  If, on the other hand, the same-looking symbol is read twice
from two different places in a program, the result is the _same_ symbol
object both times.

   Given two read symbols, you can use `eq?' to test whether they are
the same (that is, have the same name).  `eq?' is the most efficient
comparison operator in Scheme, and comparing two symbols like this is
as fast as comparing, for example, two numbers.  Given two strings, on
the other hand, you must use `equal?' or `string=?', which are much
slower comparison operators, to determine whether the strings have the
same contents.

     (define sym1 (quote hello))
     (define sym2 (quote hello))
     (eq? sym1 sym2) => #t

     (define str1 "hello")
     (define str2 "hello")
     (eq? str1 str2) => #f
     (equal? str1 str2) => #t

   The second important difference is that symbols, unlike strings, are
not self-evaluating.  This is why we need the `(quote ...)'s in the
example above: `(quote hello)' evaluates to the symbol named "hello"
itself, whereas an unquoted `hello' is _read_ as the symbol named
"hello" and evaluated as a variable reference ... about which more
below (*note Symbol Variables::).

* Menu:

* Symbol Data::                 Symbols as discrete data.
* Symbol Keys::                 Symbols as lookup keys.
* Symbol Variables::            Symbols as denoting variables.
* Symbol Primitives::           Operations related to symbols.
* Symbol Props::                Function slots and property lists.
* Symbol Read Syntax::          Extended read syntax for symbols.


File: guile.info,  Node: Symbol Data,  Next: Symbol Keys,  Up: Symbols

21.6.1 Symbols as Discrete Data
-------------------------------

Numbers and symbols are similar to the extent that they both lend
themselves to `eq?' comparison.  But symbols are more descriptive than
numbers, because a symbol's name can be used directly to describe the
concept for which that symbol stands.

   For example, imagine that you need to represent some colours in a
computer program.  Using numbers, you would have to choose arbitrarily
some mapping between numbers and colours, and then take care to use that
mapping consistently:

     ;; 1=red, 2=green, 3=purple

     (if (eq? (colour-of car) 1)
         ...)

You can make the mapping more explicit and the code more readable by
defining constants:

     (define red 1)
     (define green 2)
     (define purple 3)

     (if (eq? (colour-of car) red)
         ...)

But the simplest and clearest approach is not to use numbers at all, but
symbols whose names specify the colours that they refer to:

     (if (eq? (colour-of car) 'red)
         ...)

   The descriptive advantages of symbols over numbers increase as the
set of concepts that you want to describe grows.  Suppose that a car
object can have other properties as well, such as whether it has or
uses:

   * automatic or manual transmission

   * leaded or unleaded fuel

   * power steering (or not).

Then a car's combined property set could be naturally represented and
manipulated as a list of symbols:

     (properties-of car1)
     =>
     (red manual unleaded power-steering)

     (if (memq 'power-steering (properties-of car1))
         (display "Unfit people can drive this car.\n")
         (display "You'll need strong arms to drive this car!\n"))
     -|
     Unfit people can drive this car.

   Remember, the fundamental property of symbols that we are relying on
here is that an occurrence of `'red' in one part of a program is an
_indistinguishable_ symbol from an occurrence of `'red' in another part
of a program; this means that symbols can usefully be compared using
`eq?'.  At the same time, symbols have naturally descriptive names.
This combination of efficiency and descriptive power makes them ideal
for use as discrete data.


File: guile.info,  Node: Symbol Keys,  Next: Symbol Variables,  Prev: Symbol Data,  Up: Symbols

21.6.2 Symbols as Lookup Keys
-----------------------------

Given their efficiency and descriptive power, it is natural to use
symbols as the keys in an association list or hash table.

   To illustrate this, consider a more structured representation of the
car properties example from the preceding subsection.  Rather than
mixing all the properties up together in a flat list, we could use an
association list like this:

     (define car1-properties '((colour . red)
                               (transmission . manual)
                               (fuel . unleaded)
                               (steering . power-assisted)))

   Notice how this structure is more explicit and extensible than the
flat list.  For example it makes clear that `manual' refers to the
transmission rather than, say, the windows or the locking of the car.
It also allows further properties to use the same symbols among their
possible values without becoming ambiguous:

     (define car1-properties '((colour . red)
                               (transmission . manual)
                               (fuel . unleaded)
                               (steering . power-assisted)
                               (seat-colour . red)
                               (locking . manual)))

   With a representation like this, it is easy to use the efficient
`assq-XXX' family of procedures (*note Association Lists::) to extract
or change individual pieces of information:

     (assq-ref car1-properties 'fuel) => unleaded
     (assq-ref car1-properties 'transmission) => manual

     (assq-set! car1-properties 'seat-colour 'black)
     =>
     ((colour . red)
      (transmission . manual)
      (fuel . unleaded)
      (steering . power-assisted)
      (seat-colour . black)
      (locking . manual)))

   Hash tables also have keys, and exactly the same arguments apply to
the use of symbols in hash tables as in association lists.  The hash
value that Guile uses to decide where to add a symbol-keyed entry to a
hash table can be obtained by calling the `symbol-hash' procedure:

 -- Scheme Procedure: symbol-hash symbol
 -- C Function: scm_symbol_hash (symbol)
     Return a hash value for SYMBOL.

   See *Note Hash Tables:: for information about hash tables in
general, and for why you might choose to use a hash table rather than
an association list.


File: guile.info,  Node: Symbol Variables,  Next: Symbol Primitives,  Prev: Symbol Keys,  Up: Symbols

21.6.3 Symbols as Denoting Variables
------------------------------------

When an unquoted symbol in a Scheme program is evaluated, it is
interpreted as a variable reference, and the result of the evaluation is
the appropriate variable's value.

   For example, when the expression `(string-length "abcd")' is read
and evaluated, the sequence of characters `string-length' is read as
the symbol whose name is "string-length".  This symbol is associated
with a variable whose value is the procedure that implements string
length calculation.  Therefore evaluation of the `string-length' symbol
results in that procedure.

   The details of the connection between an unquoted symbol and the
variable to which it refers are explained elsewhere.  See *Note Binding
Constructs::, for how associations between symbols and variables are
created, and *Note Modules::, for how those associations are affected by
Guile's module system.


File: guile.info,  Node: Symbol Primitives,  Next: Symbol Props,  Prev: Symbol Variables,  Up: Symbols

21.6.4 Operations Related to Symbols
------------------------------------

Given any Scheme value, you can determine whether it is a symbol using
the `symbol?' primitive:

 -- Scheme Procedure: symbol? obj
 -- C Function: scm_symbol_p (obj)
     Return `#t' if OBJ is a symbol, otherwise return `#f'.

   Once you know that you have a symbol, you can obtain its name as a
string by calling `symbol->string'.  Note that Guile differs by default
from R5RS on the details of `symbol->string' as regards
case-sensitivity:

 -- Scheme Procedure: symbol->string s
 -- C Function: scm_symbol_to_string (s)
     Return the name of symbol S as a string.  By default, Guile reads
     symbols case-sensitively, so the string returned will have the
     same case variation as the sequence of characters that caused S to
     be created.

     If Guile is set to read symbols case-insensitively (as specified by
     R5RS), and S comes into being as part of a literal expression
     (*note Literal expressions: (r5rs)Literal expressions.) or by a
     call to the `read' or `string-ci->symbol' procedures, Guile
     converts any alphabetic characters in the symbol's name to lower
     case before creating the symbol object, so the string returned
     here will be in lower case.

     If S was created by `string->symbol', the case of characters in
     the string returned will be the same as that in the string that was
     passed to `string->symbol', regardless of Guile's case-sensitivity
     setting at the time S was created.

     It is an error to apply mutation procedures like `string-set!' to
     strings returned by this procedure.

   Most symbols are created by writing them literally in code.  However
it is also possible to create symbols programmatically using the
following `string->symbol' and `string-ci->symbol' procedures:

 -- Scheme Procedure: string->symbol string
 -- C Function: scm_string_to_symbol (string)
     Return the symbol whose name is STRING.  This procedure can create
     symbols with names containing special characters or letters in the
     non-standard case, but it is usually a bad idea to create such
     symbols because in some implementations of Scheme they cannot be
     read as themselves.

 -- Scheme Procedure: string-ci->symbol str
 -- C Function: scm_string_ci_to_symbol (str)
     Return the symbol whose name is STR.  If Guile is currently
     reading symbols case-insensitively, STR is converted to lowercase
     before the returned symbol is looked up or created.

   The following examples illustrate Guile's detailed behaviour as
regards the case-sensitivity of symbols:

     (read-enable 'case-insensitive)   ; R5RS compliant behaviour

     (symbol->string 'flying-fish)    => "flying-fish"
     (symbol->string 'Martin)         => "martin"
     (symbol->string
        (string->symbol "Malvina"))   => "Malvina"

     (eq? 'mISSISSIppi 'mississippi)  => #t
     (string->symbol "mISSISSIppi")   => mISSISSIppi
     (eq? 'bitBlt (string->symbol "bitBlt")) => #f
     (eq? 'LolliPop
       (string->symbol (symbol->string 'LolliPop))) => #t
     (string=? "K. Harper, M.D."
       (symbol->string
         (string->symbol "K. Harper, M.D."))) => #t

     (read-disable 'case-insensitive)   ; Guile default behaviour

     (symbol->string 'flying-fish)    => "flying-fish"
     (symbol->string 'Martin)         => "Martin"
     (symbol->string
        (string->symbol "Malvina"))   => "Malvina"

     (eq? 'mISSISSIppi 'mississippi)  => #f
     (string->symbol "mISSISSIppi")   => mISSISSIppi
     (eq? 'bitBlt (string->symbol "bitBlt")) => #t
     (eq? 'LolliPop
       (string->symbol (symbol->string 'LolliPop))) => #t
     (string=? "K. Harper, M.D."
       (symbol->string
         (string->symbol "K. Harper, M.D."))) => #t

   Finally, some applications, especially those that generate new Scheme
code dynamically, need to generate symbols for use in the generated
code.  The `gensym' primitive meets this need:

 -- Scheme Procedure: gensym [prefix]
 -- C Function: scm_gensym (prefix)
     Create a new symbol with a name constructed from a prefix and a
     counter value.  The string PREFIX can be specified as an optional
     argument.  Default prefix is ` g'.  The counter is increased by 1
     at each call.  There is no provision for resetting the counter.

   The symbols generated by `gensym' are _likely_ to be unique, since
their names begin with a space and it is only otherwise possible to
generate such symbols if a programmer goes out of their way to do so.
The 1.8 release of Guile will include a way of creating symbols that
are _guaranteed_ to be unique.


File: guile.info,  Node: Symbol Props,  Next: Symbol Read Syntax,  Prev: Symbol Primitives,  Up: Symbols

21.6.5 Function Slots and Property Lists
----------------------------------------

In traditional Lisp dialects, symbols are often understood as having
three kinds of value at once:

   * a "variable" value, which is used when the symbol appears in code
     in a variable reference context

   * a "function" value, which is used when the symbol appears in code
     in a function name position (i.e. as the first element in an
     unquoted list)

   * a "property list" value, which is used when the symbol is given as
     the first argument to Lisp's `put' or `get' functions.

   Although Scheme (as one of its simplifications with respect to Lisp)
does away with the distinction between variable and function namespaces,
Guile currently retains some elements of the traditional structure in
case they turn out to be useful when implementing translators for other
languages, in particular Emacs Lisp.

   Specifically, Guile symbols have two extra slots. for a symbol's
property list, and for its "function value."  The following procedures
are provided to access these slots.

 -- Scheme Procedure: symbol-fref symbol
 -- C Function: scm_symbol_fref (symbol)
     Return the contents of SYMBOL's "function slot".

 -- Scheme Procedure: symbol-fset! symbol value
 -- C Function: scm_symbol_fset_x (symbol, value)
     Set the contents of SYMBOL's function slot to VALUE.

 -- Scheme Procedure: symbol-pref symbol
 -- C Function: scm_symbol_pref (symbol)
     Return the "property list" currently associated with SYMBOL.

 -- Scheme Procedure: symbol-pset! symbol value
 -- C Function: scm_symbol_pset_x (symbol, value)
     Set SYMBOL's property list to VALUE.

 -- Scheme Procedure: symbol-property sym prop
     From SYM's property list, return the value for property PROP.  The
     assumption is that SYM's property list is an association list
     whose keys are distinguished from each other using `equal?'; PROP
     should be one of the keys in that list.  If the property list has
     no entry for PROP, `symbol-property' returns `#f'.

 -- Scheme Procedure: set-symbol-property! sym prop val
     In SYM's property list, set the value for property PROP to VAL, or
     add a new entry for PROP, with value VAL, if none already exists.
     For the structure of the property list, see `symbol-property'.

 -- Scheme Procedure: symbol-property-remove! sym prop
     From SYM's property list, remove the entry for property PROP, if
     there is one.  For the structure of the property list, see
     `symbol-property'.

   Support for these extra slots may be removed in a future release,
and it is probably better to avoid using them.  (In release 1.6, Guile
itself uses the property list slot sparingly, and the function slot not
at all.)  For a more modern and Schemely approach to properties, see
*Note Object Properties::.


File: guile.info,  Node: Symbol Read Syntax,  Prev: Symbol Props,  Up: Symbols

21.6.6 Extended Read Syntax for Symbols
---------------------------------------

The read syntax for a symbol is a sequence of letters, digits, and
"extended alphabetic characters", beginning with a character that
cannot begin a number.  In addition, the special cases of `+', `-', and
`...' are read as symbols even though numbers can begin with `+', `-'
or `.'.

   Extended alphabetic characters may be used within identifiers as if
they were letters.  The set of extended alphabetic characters is:

     ! $ % & * + - . / : < = > ? @ ^ _ ~

   In addition to the standard read syntax defined above (which is taken
from R5RS (*note Formal syntax: (r5rs)Formal syntax.)), Guile provides
an extended symbol read syntax that allows the inclusion of unusual
characters such as space characters, newlines and parentheses.  If (for
whatever reason) you need to write a symbol containing characters not
mentioned above, you can do so as follows.

   * Begin the symbol with the characters `#{',

   * write the characters of the symbol and

   * finish the symbol with the characters `}#'.

   Here are a few examples of this form of read syntax.  The first
symbol needs to use extended syntax because it contains a space
character, the second because it contains a line break, and the last
because it looks like a number.

     #{foo bar}#

     #{what
     ever}#

     #{4242}#

   Although Guile provides this extended read syntax for symbols,
widespread usage of it is discouraged because it is not portable and not
very readable.


File: guile.info,  Node: Keywords,  Next: Other Types,  Prev: Symbols,  Up: Simple Data Types

21.7 Keywords
=============

Keywords are self-evaluating objects with a convenient read syntax that
makes them easy to type.

   Guile's keyword support conforms to R5RS, and adds a (switchable)
read syntax extension to permit keywords to begin with `:' as well as
`#:'.

* Menu:

* Why Use Keywords?::           Motivation for keyword usage.
* Coding With Keywords::        How to use keywords.
* Keyword Read Syntax::         Read syntax for keywords.
* Keyword Procedures::          Procedures for dealing with keywords.
* Keyword Primitives::          The underlying primitive procedures.


File: guile.info,  Node: Why Use Keywords?,  Next: Coding With Keywords,  Up: Keywords

21.7.1 Why Use Keywords?
------------------------

Keywords are useful in contexts where a program or procedure wants to be
able to accept a large number of optional arguments without making its
interface unmanageable.

   To illustrate this, consider a hypothetical `make-window' procedure,
which creates a new window on the screen for drawing into using some
graphical toolkit.  There are many parameters that the caller might
like to specify, but which could also be sensibly defaulted, for
example:

   * color depth - Default: the color depth for the screen

   * background color - Default: white

   * width - Default: 600

   * height - Default: 400

   If `make-window' did not use keywords, the caller would have to pass
in a value for each possible argument, remembering the correct argument
order and using a special value to indicate the default value for that
argument:

     (make-window 'default              ;; Color depth
                  'default              ;; Background color
                  800                   ;; Width
                  100                   ;; Height
                  ...)                  ;; More make-window arguments

   With keywords, on the other hand, defaulted arguments are omitted,
and non-default arguments are clearly tagged by the appropriate
keyword.  As a result, the invocation becomes much clearer:

     (make-window #:width 800 #:height 100)

   On the other hand, for a simpler procedure with few arguments, the
use of keywords would be a hindrance rather than a help.  The primitive
procedure `cons', for example, would not be improved if it had to be
invoked as

     (cons #:car x #:cdr y)

   So the decision whether to use keywords or not is purely pragmatic:
use them if they will clarify the procedure invocation at point of call.


File: guile.info,  Node: Coding With Keywords,  Next: Keyword Read Syntax,  Prev: Why Use Keywords?,  Up: Keywords

21.7.2 Coding With Keywords
---------------------------

If a procedure wants to support keywords, it should take a rest argument
and then use whatever means is convenient to extract keywords and their
corresponding arguments from the contents of that rest argument.

   The following example illustrates the principle: the code for
`make-window' uses a helper procedure called `get-keyword-value' to
extract individual keyword arguments from the rest argument.

     (define (get-keyword-value args keyword default)
       (let ((kv (memq keyword args)))
         (if (and kv (>= (length kv) 2))
             (cadr kv)
             default)))

     (define (make-window . args)
       (let ((depth  (get-keyword-value args #:depth  screen-depth))
             (bg     (get-keyword-value args #:bg     "white"))
             (width  (get-keyword-value args #:width  800))
             (height (get-keyword-value args #:height 100))
             ...)
         ...))

   But you don't need to write `get-keyword-value'.  The `(ice-9
optargs)' module provides a set of powerful macros that you can use to
implement keyword-supporting procedures like this:

     (use-modules (ice-9 optargs))

     (define (make-window . args)
       (let-keywords args #f ((depth  screen-depth)
                              (bg     "white")
                              (width  800)
                              (height 100))
         ...))

Or, even more economically, like this:

     (use-modules (ice-9 optargs))

     (define* (make-window #:key (depth  screen-depth)
                                 (bg     "white")
                                 (width  800)
                                 (height 100))
       ...)

   For further details on `let-keywords', `define*' and other
facilities provided by the `(ice-9 optargs)' module, see *Note Optional
Arguments::.


File: guile.info,  Node: Keyword Read Syntax,  Next: Keyword Procedures,  Prev: Coding With Keywords,  Up: Keywords

21.7.3 Keyword Read Syntax
--------------------------

Guile, by default, only recognizes the keyword syntax specified by R5RS.
A token of the form `#:NAME', where `NAME' has the same syntax as a
Scheme symbol (*note Symbol Read Syntax::), is the external
representation of the keyword named `NAME'.  Keyword objects print
using this syntax as well, so values containing keyword objects can be
read back into Guile.  When used in an expression, keywords are
self-quoting objects.

   If the `keyword' read option is set to `'prefix', Guile also
recognizes the alternative read syntax `:NAME'.  Otherwise, tokens of
the form `:NAME' are read as symbols, as required by R5RS.

   To enable and disable the alternative non-R5RS keyword syntax, you
use the `read-set!' procedure documented in *Note User level options
interfaces:: and *Note Reader options::.

     (read-set! keywords 'prefix)

     #:type
     =>
     #:type

     :type
     =>
     #:type

     (read-set! keywords #f)

     #:type
     =>
     #:type

     :type
     -|
     ERROR: In expression :type:
     ERROR: Unbound variable: :type
     ABORT: (unbound-variable)


File: guile.info,  Node: Keyword Procedures,  Next: Keyword Primitives,  Prev: Keyword Read Syntax,  Up: Keywords

21.7.4 Keyword Procedures
-------------------------

The following procedures can be used for converting symbols to keywords
and back.

 -- Scheme Procedure: symbol->keyword sym
     Return a keyword with the same characters as in SYM.

 -- Scheme Procedure: keyword->symbol kw
     Return a symbol with the same characters as in KW.


File: guile.info,  Node: Keyword Primitives,  Prev: Keyword Procedures,  Up: Keywords

21.7.5 Keyword Primitives
-------------------------

Internally, a keyword is implemented as something like a tagged symbol,
where the tag identifies the keyword as being self-evaluating, and the
symbol, known as the keyword's "dash symbol" has the same name as the
keyword name but prefixed by a single dash.  For example, the keyword
`#:name' has the corresponding dash symbol `-name'.

   Most keyword objects are constructed automatically by the reader
when it reads a token beginning with `#:'.  However, if you need to
construct a keyword object programmatically, you can do so by calling
`make-keyword-from-dash-symbol' with the corresponding dash symbol (as
the reader does).  The dash symbol for a keyword object can be
retrieved using the `keyword-dash-symbol' procedure.

 -- Scheme Procedure: make-keyword-from-dash-symbol symbol
 -- C Function: scm_make_keyword_from_dash_symbol (symbol)
     Make a keyword object from a SYMBOL that starts with a dash.

 -- Scheme Procedure: keyword? obj
 -- C Function: scm_keyword_p (obj)
     Return `#t' if the argument OBJ is a keyword, else `#f'.

 -- Scheme Procedure: keyword-dash-symbol keyword
 -- C Function: scm_keyword_dash_symbol (keyword)
     Return the dash symbol for KEYWORD.  This is the inverse of
     `make-keyword-from-dash-symbol'.


File: guile.info,  Node: Other Types,  Prev: Keywords,  Up: Simple Data Types

21.8 "Functionality-Centric" Data Types
=======================================

Procedures and macros are documented in their own chapter: see *Note
Procedures and Macros::.

   Variable objects are documented as part of the description of Guile's
module system: see *Note Variables::.

   Asyncs, dynamic roots and fluids are described in the chapter on
scheduling: see *Note Scheduling::.

   Hooks are documented in the chapter on general utility functions: see
*Note Hooks::.

   Ports are described in the chapter on I/O: see *Note Input and
Output::.


File: guile.info,  Node: Compound Data Types,  Next: Procedures and Macros,  Prev: Simple Data Types,  Up: Top

22 Compound Data Types
**********************

This chapter describes Guile's compound data types.  By "compound" we
mean that the primary purpose of these data types is to act as
containers for other kinds of data (including other compound objects).
For instance, a (non-uniform) vector with length 5 is a container that
can hold five arbitrary Scheme objects.

   The various kinds of container object differ from each other in how
their memory is allocated, how they are indexed, and how particular
values can be looked up within them.

* Menu:

* Pairs::                       Scheme's basic building block.
* Lists::                       Special list functions supported by Guile.
* Vectors::                     One-dimensional arrays of Scheme objects.
* Records::
* Structures::
* Arrays::                      Arrays of values.
* Association Lists and Hash Tables::  Dictionary data types.


File: guile.info,  Node: Pairs,  Next: Lists,  Up: Compound Data Types

22.1 Pairs
==========

Pairs are used to combine two Scheme objects into one compound object.
Hence the name: A pair stores a pair of objects.

   The data type "pair" is extremely important in Scheme, just like in
any other Lisp dialect.  The reason is that pairs are not only used to
make two values available as one object, but that pairs are used for
constructing lists of values.  Because lists are so important in Scheme,
they are described in a section of their own (*note Lists::).

   Pairs can literally get entered in source code or at the REPL, in the
so-called "dotted list" syntax.  This syntax consists of an opening
parentheses, the first element of the pair, a dot, the second element
and a closing parentheses.  The following example shows how a pair
consisting of the two numbers 1 and 2, and a pair containing the symbols
`foo' and `bar' can be entered.  It is very important to write the
whitespace before and after the dot, because otherwise the Scheme
parser would not be able to figure out where to split the tokens.

     (1 . 2)
     (foo . bar)

   But beware, if you want to try out these examples, you have to
"quote" the expressions.  More information about quotation is available
in the section (REFFIXME).  The correct way to try these examples is as
follows.

     '(1 . 2)
     =>
     (1 . 2)
     '(foo . bar)
     =>
     (foo . bar)

   A new pair is made by calling the procedure `cons' with two
arguments.  Then the argument values are stored into a newly allocated
pair, and the pair is returned.  The name `cons' stands for
"construct".  Use the procedure `pair?' to test whether a given Scheme
object is a pair or not.

 -- Scheme Procedure: cons x y
 -- C Function: scm_cons (x, y)
     Return a newly allocated pair whose car is X and whose cdr is Y.
     The pair is guaranteed to be different (in the sense of `eq?')
     from every previously existing object.

 -- Scheme Procedure: pair? x
 -- C Function: scm_pair_p (x)
     Return `#t' if X is a pair; otherwise return `#f'.

   The two parts of a pair are traditionally called "car" and "cdr".
They can be retrieved with procedures of the same name (`car' and
`cdr'), and can be modified with the procedures `set-car!' and
`set-cdr!'.  Since a very common operation in Scheme programs is to
access the car of a pair, or the car of the cdr of a pair, etc., the
procedures called `caar', `cadr' and so on are also predefined.

 -- Scheme Procedure: car pair
 -- Scheme Procedure: cdr pair
     Return the car or the cdr of PAIR, respectively.

 -- Scheme Procedure: caar pair
 -- Scheme Procedure: cadr pair ...
 -- Scheme Procedure: cdddar pair
 -- Scheme Procedure: cddddr pair
     These procedures are compositions of `car' and `cdr', where for
     example `caddr' could be defined by

          (define caddr (lambda (x) (car (cdr (cdr x)))))

 -- Scheme Procedure: set-car! pair value
 -- C Function: scm_set_car_x (pair, value)
     Stores VALUE in the car field of PAIR.  The value returned by
     `set-car!' is unspecified.

 -- Scheme Procedure: set-cdr! pair value
 -- C Function: scm_set_cdr_x (pair, value)
     Stores VALUE in the cdr field of PAIR.  The value returned by
     `set-cdr!' is unspecified.


File: guile.info,  Node: Lists,  Next: Vectors,  Prev: Pairs,  Up: Compound Data Types

22.2 Lists
==========

A very important data type in Scheme--as well as in all other Lisp
dialects--is the data type "list".(1)

   This is the short definition of what a list is:

   * Either the empty list `()',

   * or a pair which has a list in its cdr.

* Menu:

* List Syntax::                 Writing literal lists.
* List Predicates::             Testing lists.
* List Constructors::           Creating new lists.
* List Selection::              Selecting from lists, getting their length.
* Append/Reverse::              Appending and reversing lists.
* List Modification::           Modifying existing lists.
* List Searching::              Searching for list elements
* List Mapping::                Applying procedures to lists.

   ---------- Footnotes ----------

   (1) Strictly speaking, Scheme does not have a real datatype "list".
Lists are made up of "chained pairs", and only exist by definition--a
list is a chain of pairs which looks like a list.


File: guile.info,  Node: List Syntax,  Next: List Predicates,  Up: Lists

22.2.1 List Read Syntax
-----------------------

The syntax for lists is an opening parentheses, then all the elements of
the list (separated by whitespace) and finally a closing
parentheses.(1).

     (1 2 3)            ; a list of the numbers 1, 2 and 3
     ("foo" bar 3.1415) ; a string, a symbol and a real number
     ()                 ; the empty list

   The last example needs a bit more explanation.  A list with no
elements, called the "empty list", is special in some ways.  It is used
for terminating lists by storing it into the cdr of the last pair that
makes up a list.  An example will clear that up:

     (car '(1))
     =>
     1
     (cdr '(1))
     =>
     ()

   This example also shows that lists have to be quoted (REFFIXME) when
written, because they would otherwise be mistakingly taken as procedure
applications (*note Simple Invocation::).

   ---------- Footnotes ----------

   (1) Note that there is no separation character between the list
elements, like a comma or a semicolon.


File: guile.info,  Node: List Predicates,  Next: List Constructors,  Prev: List Syntax,  Up: Lists

22.2.2 List Predicates
----------------------

Often it is useful to test whether a given Scheme object is a list or
not.  List-processing procedures could use this information to test
whether their input is valid, or they could do different things
depending on the datatype of their arguments.

 -- Scheme Procedure: list? x
 -- C Function: scm_list_p (x)
     Return `#t' iff X is a proper list, else `#f'.

   The predicate `null?' is often used in list-processing code to tell
whether a given list has run out of elements.  That is, a loop somehow
deals with the elements of a list until the list satisfies `null?'.
Then, the algorithm terminates.

 -- Scheme Procedure: null? x
 -- C Function: scm_null_p (x)
     Return `#t' iff X is the empty list, else `#f'.


File: guile.info,  Node: List Constructors,  Next: List Selection,  Prev: List Predicates,  Up: Lists

22.2.3 List Constructors
------------------------

This section describes the procedures for constructing new lists.
`list' simply returns a list where the elements are the arguments,
`cons*' is similar, but the last argument is stored in the cdr of the
last pair of the list.

 -- Scheme Procedure: list . objs
 -- C Function: scm_list (objs)
     Return a list containing OBJS, the arguments to `list'.

 -- Scheme Procedure: cons* arg1 arg2 ...
 -- C Function: scm_cons_star (arg1, rest)
     Like `list', but the last arg provides the tail of the constructed
     list, returning `(cons ARG1 (cons ARG2 (cons ... ARGN)))'.
     Requires at least one argument.  If given one argument, that
     argument is returned as result.  This function is called `list*'
     in some other Schemes and in Common LISP.

 -- Scheme Procedure: list-copy lst
 -- C Function: scm_list_copy (lst)
     Return a (newly-created) copy of LST.

 -- Scheme Procedure: make-list n [init]
     Create a list containing of N elements, where each element is
     initialized to INIT.  INIT defaults to the empty list `()' if not
     given.

   Note that `list-copy' only makes a copy of the pairs which make up
the spine of the lists.  The list elements are not copied, which means
that modifying the elements of the new list also modifies the elements
of the old list.  On the other hand, applying procedures like
`set-cdr!' or `delv!' to the new list will not alter the old list.  If
you also need to copy the list elements (making a deep copy), use the
procedure `copy-tree' (*note Copying::).


File: guile.info,  Node: List Selection,  Next: Append/Reverse,  Prev: List Constructors,  Up: Lists

22.2.4 List Selection
---------------------

These procedures are used to get some information about a list, or to
retrieve one or more elements of a list.

 -- Scheme Procedure: length lst
 -- C Function: scm_length (lst)
     Return the number of elements in list LST.

 -- Scheme Procedure: last-pair lst
 -- C Function: scm_last_pair (lst)
     Return a pointer to the last pair in LST, signalling an error if
     LST is circular.

 -- Scheme Procedure: list-ref list k
 -- C Function: scm_list_ref (list, k)
     Return the Kth element from LIST.

 -- Scheme Procedure: list-tail lst k
 -- Scheme Procedure: list-cdr-ref lst k
 -- C Function: scm_list_tail (lst, k)
     Return the "tail" of LST beginning with its Kth element.  The
     first element of the list is considered to be element 0.

     `list-tail' and `list-cdr-ref' are identical.  It may help to
     think of `list-cdr-ref' as accessing the Kth cdr of the list, or
     returning the results of cdring K times down LST.

 -- Scheme Procedure: list-head lst k
 -- C Function: scm_list_head (lst, k)
     Copy the first K elements from LST into a new list, and return it.


File: guile.info,  Node: Append/Reverse,  Next: List Modification,  Prev: List Selection,  Up: Lists

22.2.5 Append and Reverse
-------------------------

`append' and `append!' are used to concatenate two or more lists in
order to form a new list.  `reverse' and `reverse!' return lists with
the same elements as their arguments, but in reverse order.  The
procedure variants with an `!' directly modify the pairs which form the
list, whereas the other procedures create new pairs.  This is why you
should be careful when using the side-effecting variants.

 -- Scheme Procedure: append . args
 -- C Function: scm_append (args)
     Return a list consisting of the elements the lists passed as
     arguments.
          (append '(x) '(y))          =>  (x y)
          (append '(a) '(b c d))      =>  (a b c d)
          (append '(a (b)) '((c)))    =>  (a (b) (c))
     The resulting list is always newly allocated, except that it
     shares structure with the last list argument.  The last argument
     may actually be any object; an improper list results if the last
     argument is not a proper list.
          (append '(a b) '(c . d))    =>  (a b c . d)
          (append '() 'a)             =>  a

 -- Scheme Procedure: append! . lists
 -- C Function: scm_append_x (lists)
     A destructive version of `append' (*note Pairs and lists:
     (r5rs)Pairs and lists.).  The cdr field of each list's final pair
     is changed to point to the head of the next list, so no consing is
     performed.  Return a pointer to the mutated list.

 -- Scheme Procedure: reverse lst
 -- C Function: scm_reverse (lst)
     Return a new list that contains the elements of LST but in reverse
     order.

 -- Scheme Procedure: reverse! lst [new_tail]
 -- C Function: scm_reverse_x (lst, new_tail)
     A destructive version of `reverse' (*note Pairs and lists:
     (r5rs)Pairs and lists.).  The cdr of each cell in LST is modified
     to point to the previous list element.  Return a pointer to the
     head of the reversed list.

     Caveat: because the list is modified in place, the tail of the
     original list now becomes its head, and the head of the original
     list now becomes the tail.  Therefore, the LST symbol to which the
     head of the original list was bound now points to the tail.  To
     ensure that the head of the modified list is not lost, it is wise
     to save the return value of `reverse!'


File: guile.info,  Node: List Modification,  Next: List Searching,  Prev: Append/Reverse,  Up: Lists

22.2.6 List Modification
------------------------

The following procedures modify an existing list, either by changing
elements of the list, or by changing the list structure itself.

 -- Scheme Procedure: list-set! list k val
 -- C Function: scm_list_set_x (list, k, val)
     Set the Kth element of LIST to VAL.

 -- Scheme Procedure: list-cdr-set! list k val
 -- C Function: scm_list_cdr_set_x (list, k, val)
     Set the Kth cdr of LIST to VAL.

 -- Scheme Procedure: delq item lst
 -- C Function: scm_delq (item, lst)
     Return a newly-created copy of LST with elements `eq?' to ITEM
     removed.  This procedure mirrors `memq': `delq' compares elements
     of LST against ITEM with `eq?'.

 -- Scheme Procedure: delv item lst
 -- C Function: scm_delv (item, lst)
     Return a newly-created copy of LST with elements `eqv?'  to ITEM
     removed.  This procedure mirrors `memv': `delv' compares elements
     of LST against ITEM with `eqv?'.

 -- Scheme Procedure: delete item lst
 -- C Function: scm_delete (item, lst)
     Return a newly-created copy of LST with elements `equal?'  to ITEM
     removed.  This procedure mirrors `member': `delete' compares
     elements of LST against ITEM with `equal?'.

 -- Scheme Procedure: delq! item lst
 -- Scheme Procedure: delv! item lst
 -- Scheme Procedure: delete! item lst
 -- C Function: scm_delq_x (item, lst)
 -- C Function: scm_delv_x (item, lst)
 -- C Function: scm_delete_x (item, lst)
     These procedures are destructive versions of `delq', `delv' and
     `delete': they modify the pointers in the existing LST rather than
     creating a new list.  Caveat evaluator: Like other destructive
     list functions, these functions cannot modify the binding of LST,
     and so cannot be used to delete the first element of LST
     destructively.

 -- Scheme Procedure: delq1! item lst
 -- C Function: scm_delq1_x (item, lst)
     Like `delq!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eq?'.  See also `delv1!' and
     `delete1!'.

 -- Scheme Procedure: delv1! item lst
 -- C Function: scm_delv1_x (item, lst)
     Like `delv!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eqv?'.  See also `delq1!' and
     `delete1!'.

 -- Scheme Procedure: delete1! item lst
 -- C Function: scm_delete1_x (item, lst)
     Like `delete!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `equal?'.  See also `delq1!' and
     `delv1!'.


File: guile.info,  Node: List Searching,  Next: List Mapping,  Prev: List Modification,  Up: Lists

22.2.7 List Searching
---------------------

The following procedures search lists for particular elements.  They use
different comparison predicates for comparing list elements with the
object to be searched.  When they fail, they return `#f', otherwise
they return the sublist whose car is equal to the search object, where
equality depends on the equality predicate used.

 -- Scheme Procedure: memq x lst
 -- C Function: scm_memq (x, lst)
     Return the first sublist of LST whose car is `eq?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

 -- Scheme Procedure: memv x lst
 -- C Function: scm_memv (x, lst)
     Return the first sublist of LST whose car is `eqv?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

 -- Scheme Procedure: member x lst
 -- C Function: scm_member (x, lst)
     Return the first sublist of LST whose car is `equal?' to X where
     the sublists of LST are the non-empty lists returned by
     `(list-tail LST K)' for K less than the length of LST.  If X does
     not occur in LST, then `#f' (not the empty list) is returned.


File: guile.info,  Node: List Mapping,  Prev: List Searching,  Up: Lists

22.2.8 List Mapping
-------------------

List processing is very convenient in Scheme because the process of
iterating over the elements of a list can be highly abstracted.  The
procedures in this section are the most basic iterating procedures for
lists.  They take a procedure and one or more lists as arguments, and
apply the procedure to each element of the list.  They differ in their
return value.

 -- Scheme Procedure: map proc arg1 arg2 ...
 -- Scheme Procedure: map-in-order proc arg1 arg2 ...
 -- C Function: scm_map (proc, arg1, args)
     Apply PROC to each element of the list ARG1 (if only two arguments
     are given), or to the corresponding elements of the argument lists
     (if more than two arguments are given).  The result(s) of the
     procedure applications are saved and returned in a list.  For
     `map', the order of procedure applications is not specified,
     `map-in-order' applies the procedure from left to right to the list
     elements.

 -- Scheme Procedure: for-each proc arg1 arg2 ...
     Like `map', but the procedure is always applied from left to right,
     and the result(s) of the procedure applications are thrown away.
     The return value is not specified.


File: guile.info,  Node: Vectors,  Next: Records,  Prev: Lists,  Up: Compound Data Types

22.3 Vectors
============

Vectors are sequences of Scheme objects.  Unlike lists, the length of a
vector, once the vector is created, cannot be changed.  The advantage of
vectors over lists is that the time required to access one element of a
vector given its "position" (synonymous with "index"), a zero-origin
number, is constant, whereas lists have an access time linear to the
position of the accessed element in the list.

   Vectors can contain any kind of Scheme object; it is even possible
to have different types of objects in the same vector.  For vectors
containing vectors, you may wish to use arrays, instead.  Note, too,
that some array procedures operate happily on vectors (*note Arrays::).

* Menu:

* Vector Syntax::               Read syntax for vectors.
* Vector Creation::             Dynamic vector creation and validation.
* Vector Accessors::            Accessing and modifying vector contents.


File: guile.info,  Node: Vector Syntax,  Next: Vector Creation,  Up: Vectors

22.3.1 Read Syntax for Vectors
------------------------------

Vectors can literally be entered in source code, just like strings,
characters or some of the other data types.  The read syntax for vectors
is as follows: A sharp sign (`#'), followed by an opening parentheses,
all elements of the vector in their respective read syntax, and finally
a closing parentheses.  The following are examples of the read syntax
for vectors; where the first vector only contains numbers and the
second three different object types: a string, a symbol and a number in
hexadecimal notation.

     #(1 2 3)
     #("Hello" foo #xdeadbeef)


File: guile.info,  Node: Vector Creation,  Next: Vector Accessors,  Prev: Vector Syntax,  Up: Vectors

22.3.2 Dynamic Vector Creation and Validation
---------------------------------------------

Instead of creating a vector implicitly by using the read syntax just
described, you can create a vector dynamically by calling one of the
`vector' and `list->vector' primitives with the list of Scheme values
that you want to place into a vector.  The size of the vector thus
created is determined implicitly by the number of arguments given.

 -- Scheme Procedure: vector . l
 -- Scheme Procedure: list->vector l
 -- C Function: scm_vector (l)
     Return a newly allocated vector composed of the given arguments.
     Analogous to `list'.

          (vector 'a 'b 'c) => #(a b c)

   (As an aside, an interesting implementation detail is that the Guile
reader reads the `#(...)' syntax by reading everything but the initial
`#' as a _list_, and then passing the list that results to
`list->vector'.  Notice how neatly this fits with the similarity
between the read (and print) syntaxes for lists and vectors.)

   The inverse operation is `vector->list':

 -- Scheme Procedure: vector->list v
 -- C Function: scm_vector_to_list (v)
     Return a newly allocated list composed of the elements of V.

          (vector->list '#(dah dah didah)) =>  (dah dah didah)
          (list->vector '(dididit dah)) =>  #(dididit dah)

   To allocate a vector with an explicitly specified size, use
`make-vector'.  With this primitive you can also specify an initial
value for the vector elements (the same value for all elements, that
is):

 -- Scheme Procedure: make-vector k [fill]
 -- C Function: scm_make_vector (k, fill)
     Return a newly allocated vector of K elements.  If a second
     argument is given, then each position is initialized to FILL.
     Otherwise the initial contents of each position is unspecified.

   To check whether an arbitrary Scheme value _is_ a vector, use the
`vector?' primitive:

 -- Scheme Procedure: vector? obj
 -- C Function: scm_vector_p (obj)
     Return `#t' if OBJ is a vector, otherwise return `#f'.


File: guile.info,  Node: Vector Accessors,  Prev: Vector Creation,  Up: Vectors

22.3.3 Accessing and Modifying Vector Contents
----------------------------------------------

`vector-length' and `vector-ref' return information about a given
vector, respectively its size and the elements that are contained in
the vector.

 -- Scheme Procedure: vector-length vector
 -- C Function: scm_vector_length vector
     Return the number of elements in VECTOR as an exact integer.

 -- Scheme Procedure: vector-ref vector k
 -- C Function: scm_vector_ref vector k
     Return the contents of position K of VECTOR.  K must be a valid
     index of VECTOR.
          (vector-ref '#(1 1 2 3 5 8 13 21) 5) => 8
          (vector-ref '#(1 1 2 3 5 8 13 21)
              (let ((i (round (* 2 (acos -1)))))
                (if (inexact? i)
                  (inexact->exact i)
                     i))) => 13

   A vector created by one of the dynamic vector constructor procedures
(*note Vector Creation::) can be modified using the following
procedures.

   _NOTE:_ According to R5RS, it is an error to use any of these
procedures on a literally read vector, because such vectors should be
considered as constants.  Currently, however, Guile does not detect this
error.

 -- Scheme Procedure: vector-set! vector k obj
 -- C Function: scm_vector_set_x vector k obj
     Store OBJ in position K of VECTOR.  K must be a valid index of
     VECTOR.  The value returned by `vector-set!' is unspecified.
          (let ((vec (vector 0 '(2 2 2 2) "Anna")))
            (vector-set! vec 1 '("Sue" "Sue"))
            vec) =>  #(0 ("Sue" "Sue") "Anna")

 -- Scheme Procedure: vector-fill! v fill
 -- C Function: scm_vector_fill_x (v, fill)
     Store FILL in every position of VECTOR.  The value returned by
     `vector-fill!' is unspecified.

 -- Scheme Procedure: vector-move-left! vec1 start1 end1 vec2 start2
 -- C Function: scm_vector_move_left_x (vec1, start1, end1, vec2,
          start2)
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-left!' copies elements in leftmost order.  Therefore,
     in the case where VEC1 and VEC2 refer to the same vector,
     `vector-move-left!' is usually appropriate when START1 is greater
     than START2.

 -- Scheme Procedure: vector-move-right! vec1 start1 end1 vec2 start2
 -- C Function: scm_vector_move_right_x (vec1, start1, end1, vec2,
          start2)
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-right!' copies elements in rightmost order.
     Therefore, in the case where VEC1 and VEC2 refer to the same
     vector, `vector-move-right!' is usually appropriate when START1 is
     less than START2.


File: guile.info,  Node: Records,  Next: Structures,  Prev: Vectors,  Up: Compound Data Types

22.4 Records
============

A "record type" is a first class object representing a user-defined
data type.  A "record" is an instance of a record type.

 -- Scheme Procedure: record? obj
     Return `#t' if OBJ is a record of any type and `#f' otherwise.

     Note that `record?' may be true of any Scheme value; there is no
     promise that records are disjoint with other Scheme types.

 -- Scheme Procedure: make-record-type type-name field-names
     Return a "record-type descriptor", a value representing a new data
     type disjoint from all others.  The TYPE-NAME argument must be a
     string, but is only used for debugging purposes (such as the
     printed representation of a record of the new type).  The
     FIELD-NAMES argument is a list of symbols naming the "fields" of a
     record of the new type.  It is an error if the list contains any
     duplicates.  It is unspecified how record-type descriptors are
     represented.

 -- Scheme Procedure: record-constructor rtd [field-names]
     Return a procedure for constructing new members of the type
     represented by RTD.  The returned procedure accepts exactly as
     many arguments as there are symbols in the given list,
     FIELD-NAMES; these are used, in order, as the initial values of
     those fields in a new record, which is returned by the constructor
     procedure.  The values of any fields not named in that list are
     unspecified.  The FIELD-NAMES argument defaults to the list of
     field names in the call to `make-record-type' that created the
     type represented by RTD; if the FIELD-NAMES argument is provided,
     it is an error if it contains any duplicates or any symbols not in
     the default list.

 -- Scheme Procedure: record-predicate rtd
     Return a procedure for testing membership in the type represented
     by RTD.  The returned procedure accepts exactly one argument and
     returns a true value if the argument is a member of the indicated
     record type; it returns a false value otherwise.

 -- Scheme Procedure: record-accessor rtd field-name
     Return a procedure for reading the value of a particular field of a
     member of the type represented by RTD.  The returned procedure
     accepts exactly one argument which must be a record of the
     appropriate type; it returns the current value of the field named
     by the symbol FIELD-NAME in that record.  The symbol FIELD-NAME
     must be a member of the list of field-names in the call to
     `make-record-type' that created the type represented by RTD.

 -- Scheme Procedure: record-modifier rtd field-name
     Return a procedure for writing the value of a particular field of a
     member of the type represented by RTD.  The returned procedure
     accepts exactly two arguments: first, a record of the appropriate
     type, and second, an arbitrary Scheme value; it modifies the field
     named by the symbol FIELD-NAME in that record to contain the given
     value.  The returned value of the modifier procedure is
     unspecified.  The symbol FIELD-NAME must be a member of the list
     of field-names in the call to `make-record-type' that created the
     type represented by RTD.

 -- Scheme Procedure: record-type-descriptor record
     Return a record-type descriptor representing the type of the given
     record.  That is, for example, if the returned descriptor were
     passed to `record-predicate', the resulting predicate would return
     a true value when passed the given record.  Note that it is not
     necessarily the case that the returned descriptor is the one that
     was passed to `record-constructor' in the call that created the
     constructor procedure that created the given record.

 -- Scheme Procedure: record-type-name rtd
     Return the type-name associated with the type represented by rtd.
     The returned value is `eqv?' to the TYPE-NAME argument given in
     the call to `make-record-type' that created the type represented by
     RTD.

 -- Scheme Procedure: record-type-fields rtd
     Return a list of the symbols naming the fields in members of the
     type represented by RTD.  The returned value is `equal?' to the
     field-names argument given in the call to `make-record-type' that
     created the type represented by RTD.


File: guile.info,  Node: Structures,  Next: Arrays,  Prev: Records,  Up: Compound Data Types

22.5 Structures
===============

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

   A "structure type" is a first class user-defined data type.  A
"structure" is an instance of a structure type.  A structure type is
itself a structure.

   Structures are less abstract and more general than traditional
records.  In fact, in Guile Scheme, records are implemented using
structures.

* Menu:

* Structure Concepts::          The structure of Structures
* Structure Layout::            Defining the layout of structure types
* Structure Basics::            make-, -ref and -set! procedures for structs
* Vtables::                     Accessing type-specific data


File: guile.info,  Node: Structure Concepts,  Next: Structure Layout,  Up: Structures

22.5.1 Structure Concepts
-------------------------

A structure object consists of a handle, structure data, and a vtable.
The handle is a Scheme value which points to both the vtable and the
structure's data.  Structure data is a dynamically allocated region of
memory, private to the structure, divided up into typed fields.  A
vtable is another structure used to hold type-specific data.  Multiple
structures can share a common vtable.

   Three concepts are key to understanding structures.

   * "layout specifications"

     Layout specifications determine how memory allocated to structures
     is divided up into fields.  Programmers must write a layout
     specification whenever a new type of structure is defined.

   * "structural accessors"

     Structure access is by field number.   There is only one set of
     accessors common to all structure objects.

   * "vtables"

     Vtables, themselves structures, are first class representations of
     disjoint sub-types of structures in general.   In most cases, when
     a new structure is created, programmers must specify a vtable for
     the new structure.   Each vtable has a field describing the layout
     of its instances.   Vtables can have additional, user-defined
     fields as well.


File: guile.info,  Node: Structure Layout,  Next: Structure Basics,  Prev: Structure Concepts,  Up: Structures

22.5.2 Structure Layout
-----------------------

When a structure is created, a region of memory is allocated to hold its
state.  The "layout" of the structure's type determines how that memory
is divided into fields.

   Each field has a specified type.  There are only three types
allowed, each corresponding to a one letter code.  The allowed types
are:

   * 'u' - unprotected

     The field holds binary data that is not GC protected.

   * 'p' - protected

     The field holds a Scheme value and is GC protected.

   * 's' - self

     The field holds a Scheme value and is GC protected.  When a
     structure is created with this type of field, the field is
     initialized to refer to the structure's own handle.  This kind of
     field is mainly useful when mixing Scheme and C code in which the
     C code may need to compute a structure's handle given only the
     address of its malloc'd data.

   Each field also has an associated access protection.   There are only
three kinds of protection, each corresponding to a one letter code.
The allowed protections are:

   * 'w' - writable

     The field can be read and written.

   * 'r' - readable

     The field can be read, but not written.

   * 'o' - opaque

     The field can be neither read nor written.   This kind of
     protection is for fields useful only to built-in routines.

   A layout specification is described by stringing together pairs of
letters: one to specify a field type and one to specify a field
protection.    For example, a traditional cons pair type object could
be described as:

     ; cons pairs have two writable fields of Scheme data
     "pwpw"

   A pair object in which the first field is held constant could be:

     "prpw"

   Binary fields, (fields of type "u"), hold one "word" each.  The size
of a word is a machine dependent value defined to be equal to the value
of the C expression: `sizeof (long)'.

   The last field of a structure layout may specify a tail array.  A
tail array is indicated by capitalizing the field's protection code
('W', 'R' or 'O').   A tail-array field is replaced by a read-only
binary data field containing an array size.   The array size is
determined at the time the structure is created.  It is followed by a
corresponding number of fields of the type specified for the tail
array.   For example, a conventional Scheme vector can be described as:

     ; A vector is an arbitrary number of writable fields holding Scheme
     ; values:
     "pW"

   In the above example, field 0 contains the size of the vector and
fields beginning at 1 contain the vector elements.

   A kind of tagged vector (a constant tag followed by conventional
vector elements) might be:

     "prpW"

   Structure layouts are represented by specially interned symbols whose
name is a string of type and protection codes.  To create a new
structure layout, use this procedure:

 -- Scheme Procedure: make-struct-layout fields
 -- C Function: scm_make_struct_layout (fields)
     Return a new structure layout object.

     FIELDS must be a string made up of pairs of characters strung
     together.  The first character of each pair describes a field
     type, the second a field protection.  Allowed types are 'p' for
     GC-protected Scheme data, 'u' for unprotected binary data, and 's'
     for a field that points to the structure itself.    Allowed
     protections are 'w' for mutable fields, 'r' for read-only fields,
     and 'o' for opaque fields.  The last field protection
     specification may be capitalized to indicate that the field is a
     tail-array.


File: guile.info,  Node: Structure Basics,  Next: Vtables,  Prev: Structure Layout,  Up: Structures

22.5.3 Structure Basics
-----------------------

This section describes the basic procedures for creating and accessing
structures.

 -- Scheme Procedure: make-struct vtable tail_array_size . init
 -- C Function: scm_make_struct (vtable, tail_array_size, init)
     Create a new structure.

     TYPE must be a vtable structure (*note Vtables::).

     TAIL-ELTS must be a non-negative integer.  If the layout
     specification indicated by TYPE includes a tail-array, this is the
     number of elements allocated to that array.

     The INIT1, ... are optional arguments describing how successive
     fields of the structure should be initialized.  Only fields with
     protection 'r' or 'w' can be initialized, except for fields of
     type 's', which are automatically initialized to point to the new
     structure itself; fields with protection 'o' can not be
     initialized by Scheme programs.

     If fewer optional arguments than initializable fields are supplied,
     fields of type 'p' get default value #f while fields of type 'u'
     are initialized to 0.

     Structs are currently the basic representation for record-like data
     structures in Guile.  The plan is to eventually replace them with a
     new representation which will at the same time be easier to use and
     more powerful.

     For more information, see the documentation for
     `make-vtable-vtable'.

 -- Scheme Procedure: struct? x
 -- C Function: scm_struct_p (x)
     Return `#t' iff X is a structure object, else `#f'.

 -- Scheme Procedure: struct-ref handle pos
 -- Scheme Procedure: struct-set! struct n value
 -- C Function: scm_struct_ref (handle, pos)
 -- C Function: scm_struct_set_x (struct, n, value)
     Access (or modify) the Nth field of STRUCT.

     If the field is of type 'p', then it can be set to an arbitrary
     value.

     If the field is of type 'u', then it can only be set to a
     non-negative integer value small enough to fit in one machine word.


File: guile.info,  Node: Vtables,  Prev: Structure Basics,  Up: Structures

22.5.4 Vtables
--------------

Vtables are structures that are used to represent structure types.  Each
vtable contains a layout specification in field `vtable-index-layout' -
instances of the type are laid out according to that specification.
Vtables contain additional fields which are used only internally to
libguile.  The variable `vtable-offset-user' is bound to a field
number.  Vtable fields at that position or greater are user definable.

 -- Scheme Procedure: struct-vtable handle
 -- C Function: scm_struct_vtable (handle)
     Return the vtable structure that describes the type of STRUCT.

 -- Scheme Procedure: struct-vtable? x
 -- C Function: scm_struct_vtable_p (x)
     Return `#t' iff X is a vtable structure.

   If you have a vtable structure, `V', you can create an instance of
the type it describes by using `(make-struct V ...)'.  But where does
`V' itself come from?  One possibility is that `V' is an instance of a
user-defined vtable type, `V'', so that `V' is created by using
`(make-struct V' ...)'.  Another possibility is that `V' is an instance
of the type it itself describes.  Vtable structures of the second sort
are created by this procedure:

 -- Scheme Procedure: make-vtable-vtable user_fields tail_array_size .
          init
 -- C Function: scm_make_vtable_vtable (user_fields, tail_array_size,
          init)
     Return a new, self-describing vtable structure.

     USER-FIELDS is a string describing user defined fields of the
     vtable beginning at index `vtable-offset-user' (see
     `make-struct-layout').

     TAIL-SIZE specifies the size of the tail-array (if any) of this
     vtable.

     INIT1, ... are the optional initializers for the fields of the
     vtable.

     Vtables have one initializable system field--the struct printer.
     This field comes before the user fields in the initializers passed
     to `make-vtable-vtable' and `make-struct', and thus works as a
     third optional argument to `make-vtable-vtable' and a fourth to
     `make-struct' when creating vtables:

     If the value is a procedure, it will be called instead of the
     standard printer whenever a struct described by this vtable is
     printed.  The procedure will be called with arguments STRUCT and
     PORT.

     The structure of a struct is described by a vtable, so the vtable
     is in essence the type of the struct.  The vtable is itself a
     struct with a vtable.  This could go on forever if it weren't for
     the vtable-vtables which are self-describing vtables, and thus
     terminate the chain.

     There are several potential ways of using structs, but the standard
     one is to use three kinds of structs, together building up a type
     sub-system: one vtable-vtable working as the root and one or
     several "types", each with a set of "instances".  (The
     vtable-vtable should be compared to the class <class> which is the
     class of itself.)

          (define ball-root (make-vtable-vtable "pr" 0))

          (define (make-ball-type ball-color)
            (make-struct ball-root 0
          	       (make-struct-layout "pw")
                         (lambda (ball port)
                           (format port "#<a ~A ball owned by ~A>"
                                   (color ball)
                                   (owner ball)))
                         ball-color))
          (define (color ball) (struct-ref (struct-vtable ball) vtable-offset-user))
          (define (owner ball) (struct-ref ball 0))

          (define red (make-ball-type 'red))
          (define green (make-ball-type 'green))

          (define (make-ball type owner) (make-struct type 0 owner))

          (define ball (make-ball green 'Nisse))
          ball => #<a green ball owned by Nisse>

 -- Scheme Procedure: struct-vtable-name vtable
 -- C Function: scm_struct_vtable_name (vtable)
     Return the name of the vtable VTABLE.

 -- Scheme Procedure: set-struct-vtable-name! vtable name
 -- C Function: scm_set_struct_vtable_name_x (vtable, name)
     Set the name of the vtable VTABLE to NAME.

 -- Scheme Procedure: struct-vtable-tag handle
 -- C Function: scm_struct_vtable_tag (handle)
     Return the vtable tag of the structure HANDLE.


File: guile.info,  Node: Arrays,  Next: Association Lists and Hash Tables,  Prev: Structures,  Up: Compound Data Types

22.6 Arrays
===========

* Menu:

* Conventional Arrays::         Arrays with arbitrary data.
* Array Mapping::               Applying a procedure to the contents of an array.
* Uniform Arrays::              Arrays with data of a single type.
* Bit Vectors::                 Vectors of bits.


File: guile.info,  Node: Conventional Arrays,  Next: Array Mapping,  Up: Arrays

22.6.1 Conventional Arrays
--------------------------

"Conventional arrays" are a collection of cells organized into an
arbitrary number of dimensions.  Each cell can hold any kind of Scheme
value and can be accessed in constant time by supplying an index for
each dimension.  This contrasts with uniform arrays, which use memory
more efficiently but can hold data of only a single type, and lists
where inserting and deleting cells is more efficient, but more time is
usually required to access a particular cell.

   A conventional array is displayed as `#' followed by the "rank"
(number of dimensions) followed by the cells, organized into dimensions
using parentheses.  The nesting depth of the parentheses is equal to
the rank.

   When an array is created, the number of dimensions and range of each
dimension must be specified, e.g., to create a 2x3 array with a
zero-based index:

     (make-array 'ho 2 3) =>
     #2((ho ho ho) (ho ho ho))

   The range of each dimension can also be given explicitly, e.g.,
another way to create the same array:

     (make-array 'ho '(0 1) '(0 2)) =>
     #2((ho ho ho) (ho ho ho))

   A conventional array with one dimension based at zero is identical to
a vector:

     (make-array 'ho 3) =>
     #(ho ho ho)

   The following procedures can be used with conventional arrays (or
vectors).

 -- Scheme Procedure: array? v [prot]
 -- C Function: scm_array_p (v, prot)
     Return `#t' if the OBJ is an array, and `#f' if not.  The
     PROTOTYPE argument is used with uniform arrays and is described
     elsewhere.

 -- Scheme Procedure: make-array initial-value bound1 bound2 ...
     Create and return an array that has as many dimensions as there are
     BOUNDs and fill it with INITIAL-VALUE.  Each BOUND may be a
     positive non-zero integer N, in which case the index for that
     dimension can range from 0 through N-1; or an explicit index range
     specifier in the form `(LOWER UPPER)', where both LOWER and UPPER
     are integers, possibly less than zero, and possibly the same
     number (however, LOWER cannot be greater than UPPER).

 -- Scheme Procedure: uniform-vector-ref v args
 -- Scheme Procedure: array-ref v . args
 -- C Function: scm_uniform_vector_ref (v, args)
     Return the element at the `(index1, index2)' element in ARRAY.

 -- Scheme Procedure: array-in-bounds? v . args
 -- C Function: scm_array_in_bounds_p (v, args)
     Return `#t' if its arguments would be acceptable to `array-ref'.

 -- Scheme Procedure: array-set! v obj . args
 -- Scheme Procedure: uniform-array-set1! v obj args
 -- C Function: scm_array_set_x (v, obj, args)
     Set the element at the `(index1, index2)' element in ARRAY to
     NEW-VALUE.  The value returned by array-set! is unspecified.

 -- Scheme Procedure: make-shared-array oldra mapfunc . dims
 -- C Function: scm_make_shared_array (oldra, mapfunc, dims)
     `make-shared-array' can be used to create shared subarrays of other
     arrays.  The MAPPER is a function that translates coordinates in
     the new array into coordinates in the old array.  A MAPPER must be
     linear, and its range must stay within the bounds of the old
     array, but it can be otherwise arbitrary.  A simple example:
          (define fred (make-array #f 8 8))
          (define freds-diagonal
            (make-shared-array fred (lambda (i) (list i i)) 8))
          (array-set! freds-diagonal 'foo 3)
          (array-ref fred 3 3) => foo
          (define freds-center
            (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
          (array-ref freds-center 0 0) => foo

 -- Scheme Procedure: shared-array-increments ra
 -- C Function: scm_shared_array_increments (ra)
     For each dimension, return the distance between elements in the
     root vector.

 -- Scheme Procedure: shared-array-offset ra
 -- C Function: scm_shared_array_offset (ra)
     Return the root vector index of the first element in the array.

 -- Scheme Procedure: shared-array-root ra
 -- C Function: scm_shared_array_root (ra)
     Return the root vector of a shared array.

 -- Scheme Procedure: transpose-array ra . args
 -- C Function: scm_transpose_array (ra, args)
     Return an array sharing contents with ARRAY, but with dimensions
     arranged in a different order.  There must be one DIM argument for
     each dimension of ARRAY.  DIM0, DIM1, ... should be integers
     between 0 and the rank of the array to be returned.  Each integer
     in that range must appear at least once in the argument list.

     The values of DIM0, DIM1, ... correspond to dimensions in the
     array to be returned, their positions in the argument list to
     dimensions of ARRAY.  Several DIMs may have the same value, in
     which case the returned array will have smaller rank than ARRAY.

          (transpose-array '#2((a b) (c d)) 1 0) => #2((a c) (b d))
          (transpose-array '#2((a b) (c d)) 0 0) => #1(a d)
          (transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) =>
                          #2((a 4) (b 5) (c 6))

 -- Scheme Procedure: enclose-array ra . axes
 -- C Function: scm_enclose_array (ra, axes)
     DIM0, DIM1 ... should be nonnegative integers less than the rank
     of ARRAY.  ENCLOSE-ARRAY returns an array resembling an array of
     shared arrays.  The dimensions of each shared array are the same
     as the DIMth dimensions of the original array, the dimensions of
     the outer array are the same as those of the original array that
     did not match a DIM.

     An enclosed array is not a general Scheme array.  Its elements may
     not be set using `array-set!'.  Two references to the same element
     of an enclosed array will be `equal?' but will not in general be
     `eq?'.  The value returned by ARRAY-PROTOTYPE when given an
     enclosed array is unspecified.

     examples:
          (enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1) =>
             #<enclosed-array (#1(a d) #1(b e) #1(c f)) (#1(1 4) #1(2 5) #1(3 6))>

          (enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 0) =>
             #<enclosed-array #2((a 1) (d 4)) #2((b 2) (e 5)) #2((c 3) (f 6))>

 -- Scheme Procedure: array-shape array
     Return a list of inclusive bounds of integers.
          (array-shape (make-array 'foo '(-1 3) 5)) => ((-1 3) (0 4))

 -- Scheme Procedure: array-dimensions ra
 -- C Function: scm_array_dimensions (ra)
     `Array-dimensions' is similar to `array-shape' but replaces
     elements with a `0' minimum with one greater than the maximum. So:
          (array-dimensions (make-array 'foo '(-1 3) 5)) => ((-1 3) 5)

 -- Scheme Procedure: array-rank ra
 -- C Function: scm_array_rank (ra)
     Return the number of dimensions of OBJ.  If OBJ is not an array,
     `0' is returned.

 -- Scheme Procedure: array->list v
 -- C Function: scm_array_to_list (v)
     Return a list consisting of all the elements, in order, of ARRAY.

 -- Scheme Procedure: array-copy! src dst
 -- Scheme Procedure: array-copy-in-order! src dst
 -- C Function: scm_array_copy_x (src, dst)
     Copy every element from vector or array SOURCE to the
     corresponding element of DESTINATION.  DESTINATION must have the
     same rank as SOURCE, and be at least as large in each dimension.
     The order is unspecified.

 -- Scheme Procedure: array-fill! ra fill
 -- C Function: scm_array_fill_x (ra, fill)
     Store FILL in every element of ARRAY.  The value returned is
     unspecified.

 -- Scheme Procedure: array-equal? ra0 ra1
     Return `#t' iff all arguments are arrays with the same shape, the
     same type, and have corresponding elements which are either
     `equal?'  or `array-equal?'.  This function differs from `equal?'
     in that a one dimensional shared array may be ARRAY-EQUAL? but not
     EQUAL? to a vector or uniform vector.

 -- Scheme Procedure: array-contents array [strict]
 -- C Function: scm_array_contents (array, strict)
     If ARRAY may be "unrolled" into a one dimensional shared array
     without changing their order (last subscript changing fastest),
     then `array-contents' returns that shared array, otherwise it
     returns `#f'.  All arrays made by MAKE-ARRAY and
     MAKE-UNIFORM-ARRAY may be unrolled, some arrays made by
     MAKE-SHARED-ARRAY may not be.

     If the optional argument STRICT is provided, a shared array will
     be returned only if its elements are stored internally contiguous
     in memory.


File: guile.info,  Node: Array Mapping,  Next: Uniform Arrays,  Prev: Conventional Arrays,  Up: Arrays

22.6.2 Array Mapping
--------------------

 -- Scheme Procedure: array-map! ra0 proc . lra
 -- Scheme Procedure: array-map-in-order! ra0 proc . lra
 -- C Function: scm_array_map_x (ra0, proc, lra)
     ARRAY1, ... must have the same number of dimensions as ARRAY0 and
     have a range for each index which includes the range for the
     corresponding index in ARRAY0.  PROC is applied to each tuple of
     elements of ARRAY1 ... and the result is stored as the
     corresponding element in ARRAY0.  The value returned is
     unspecified.  The order of application is unspecified.

 -- Scheme Procedure: array-for-each proc ra0 . lra
 -- C Function: scm_array_for_each (proc, ra0, lra)
     Apply PROC to each tuple of elements of ARRAY0 ...  in row-major
     order.  The value returned is unspecified.

 -- Scheme Procedure: array-index-map! ra proc
 -- C Function: scm_array_index_map_x (ra, proc)
     Apply PROC to the indices of each element of ARRAY in turn,
     storing the result in the corresponding element.  The value
     returned and the order of application are unspecified.

     One can implement ARRAY-INDEXES as
          (define (array-indexes array)
              (let ((ra (apply make-array #f (array-shape array))))
                (array-index-map! ra (lambda x x))
                ra))
     Another example:
          (define (apl:index-generator n)
              (let ((v (make-uniform-vector n 1)))
                (array-index-map! v (lambda (i) i))
                v))


File: guile.info,  Node: Uniform Arrays,  Next: Bit Vectors,  Prev: Array Mapping,  Up: Arrays

22.6.3 Uniform Arrays
---------------------

"Uniform arrays" have elements all of the same type and occupy less
storage than conventional arrays.  Uniform arrays with a single
zero-based dimension are also known as "uniform vectors".  The
procedures in this section can also be used on conventional arrays,
vectors, bit-vectors and strings.

When creating a uniform array, the type of data to be stored is
indicated with a PROTOTYPE argument.  The following table lists the
types available and example prototypes:

     prototype           type                       printing character

     #t             boolean (bit-vector)                    b
     #\a            char (string)                           a
     #\nul          byte (integer)                          y
     's             short (integer)                         h
     1              unsigned long (integer)                 u
     -1             signed long (integer)                   e
     'l             signed long long (integer)              l
     1.0            float (single precision)                s
     1/3            double (double precision float)         i
     0+i            complex (double precision)              c
     ()             conventional vector

Unshared uniform arrays of characters with a single zero-based dimension
are identical to strings:

     (make-uniform-array #\a 3) =>
     "aaa"

Unshared uniform arrays of booleans with a single zero-based dimension
are identical to *Note bit-vectors: Bit Vectors.

     (make-uniform-array #t 3) =>
     #*111

Other uniform vectors are written in a form similar to that of vectors,
except that a single character from the above table is put between `#'
and `('.  For example, a uniform vector of signed long integers is
displayed in the form `'#e(3 5 9)'.

 -- Scheme Procedure: array? v [prot]
     Return `#t' if the OBJ is an array, and `#f' if not.

     The PROTOTYPE argument is used with uniform arrays and is described
     elsewhere.

 -- Scheme Procedure: make-uniform-array prototype bound1 bound2 ...
     Create and return a uniform array of type corresponding to
     PROTOTYPE that has as many dimensions as there are BOUNDs and fill
     it with PROTOTYPE.

 -- Scheme Procedure: array-prototype ra
 -- C Function: scm_array_prototype (ra)
     Return an object that would produce an array of the same type as
     ARRAY, if used as the PROTOTYPE for `make-uniform-array'.

 -- Scheme Procedure: list->uniform-array ndim prot lst
 -- Scheme Procedure: list->uniform-vector prot lst
 -- C Function: scm_list_to_uniform_array (ndim, prot, lst)
     Return a uniform array of the type indicated by prototype PROT
     with elements the same as those of LST.  Elements must be of the
     appropriate type, no coercions are done.

 -- Scheme Procedure: uniform-vector-fill! uve fill
     Store FILL in every element of UVE.  The value returned is
     unspecified.

 -- Scheme Procedure: uniform-vector-length v
 -- C Function: scm_uniform_vector_length (v)
     Return the number of elements in UVE.

 -- Scheme Procedure: dimensions->uniform-array dims prot [fill]
 -- Scheme Procedure: make-uniform-vector length prototype [fill]
 -- C Function: scm_dimensions_to_uniform_array (dims, prot, fill)
     Create and return a uniform array or vector of type corresponding
     to PROTOTYPE with dimensions DIMS or length LENGTH.  If FILL is
     supplied, it's used to fill the array, otherwise PROTOTYPE is used.

 -- Scheme Procedure: uniform-array-read! ra [port_or_fd [start [end]]]
 -- Scheme Procedure: uniform-vector-read! uve [port-or-fdes] [start]
          [end]
 -- C Function: scm_uniform_array_read_x (ra, port_or_fd, start, end)
     Attempt to read all elements of URA, in lexicographic order, as
     binary objects from PORT-OR-FDES.  If an end of file is
     encountered, the objects up to that point are put into URA
     (starting at the beginning) and the remainder of the array is
     unchanged.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be read, leaving the remainder of
     the vector unchanged.

     `uniform-array-read!' returns the number of objects read.
     PORT-OR-FDES may be omitted, in which case it defaults to the value
     returned by `(current-input-port)'.

 -- Scheme Procedure: uniform-array-write v [port_or_fd [start [end]]]
 -- Scheme Procedure: uniform-vector-write uve [port-or-fdes] [start]
          [end]
 -- C Function: scm_uniform_array_write (v, port_or_fd, start, end)
     Writes all elements of URA as binary objects to PORT-OR-FDES.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be written.

     The number of objects actually written is returned.  PORT-OR-FDES
     may be omitted, in which case it defaults to the value returned by
     `(current-output-port)'.


File: guile.info,  Node: Bit Vectors,  Prev: Uniform Arrays,  Up: Arrays

22.6.4 Bit Vectors
------------------

Bit vectors are a specific type of uniform array: an array of booleans
with a single zero-based index.

They are displayed as a sequence of `0's and `1's prefixed by `#*',
e.g.,

     (make-uniform-vector 8 #t #f) =>
     #*00000000

     #b(#t #f #t) =>
     #*101

 -- Scheme Procedure: bit-count b bitvector
 -- C Function: scm_bit_count (b, bitvector)
     Return the number of occurrences of the boolean B in BITVECTOR.

 -- Scheme Procedure: bit-position item v k
 -- C Function: scm_bit_position (item, v, k)
     Return the minimum index of an occurrence of BOOL in BV which is
     at least K.  If no BOOL occurs within the specified range `#f' is
     returned.

 -- Scheme Procedure: bit-invert! v
 -- C Function: scm_bit_invert_x (v)
     Modify BV by replacing each element with its negation.

 -- Scheme Procedure: bit-set*! v kv obj
 -- C Function: scm_bit_set_star_x (v, kv, obj)
     If uve is a bit-vector BV and uve must be of the same length.  If
     BOOL is `#t', uve is OR'ed into BV; If BOOL is `#f', the inversion
     of uve is AND'ed into BV.

     If uve is a unsigned long integer vector all the elements of uve
     must be between 0 and the `length' of BV.  The bits of BV
     corresponding to the indexes in uve are set to BOOL.  The return
     value is unspecified.

 -- Scheme Procedure: bit-count* v kv obj
 -- C Function: scm_bit_count_star (v, kv, obj)
     Return
          (bit-count (bit-set*! (if bool bv (bit-invert! bv)) uve #t) #t).
     BV is not modified.


File: guile.info,  Node: Association Lists and Hash Tables,  Prev: Arrays,  Up: Compound Data Types

22.7 Association Lists and Hash Tables
======================================

This chapter discusses dictionary objects: data structures that are
useful for organizing and indexing large bodies of information.

* Menu:

* Dictionary Types::            About dictionary types; what they're good for.
* Association Lists::           List-based dictionaries.
* Hash Tables::                 Table-based dictionaries.


File: guile.info,  Node: Dictionary Types,  Next: Association Lists,  Up: Association Lists and Hash Tables

22.7.1 Dictionary Types
-----------------------

A "dictionary" object is a data structure used to index information in
a user-defined way.  In standard Scheme, the main aggregate data types
are lists and vectors.  Lists are not really indexed at all, and
vectors are indexed only by number (e.g. `(vector-ref foo 5)').  Often
you will find it useful to index your data on some other type; for
example, in a library catalog you might want to look up a book by the
name of its author.  Dictionaries are used to help you organize
information in such a way.

   An "association list" (or "alist" for short) is a list of key-value
pairs.  Each pair represents a single quantity or object; the `car' of
the pair is a key which is used to identify the object, and the `cdr'
is the object's value.

   A "hash table" also permits you to index objects with arbitrary
keys, but in a way that makes looking up any one object extremely fast.
A well-designed hash system makes hash table lookups almost as fast as
conventional array or vector references.

   Alists are popular among Lisp programmers because they use only the
language's primitive operations (lists, "car", "cdr" and the equality
primitives).  No changes to the language core are necessary.
Therefore, with Scheme's built-in list manipulation facilities, it is
very convenient to handle data stored in an association list.  Also,
alists are highly portable and can be easily implemented on even the
most minimal Lisp systems.

   However, alists are inefficient, especially for storing large
quantities of data.  Because we want Guile to be useful for large
software systems as well as small ones, Guile provides a rich set of
tools for using either association lists or hash tables.


File: guile.info,  Node: Association Lists,  Next: Hash Tables,  Prev: Dictionary Types,  Up: Association Lists and Hash Tables

22.7.2 Association Lists
------------------------

An association list is a conventional data structure that is often used
to implement simple key-value databases.  It consists of a list of
entries in which each entry is a pair.  The "key" of each entry is the
`car' of the pair and the "value" of each entry is the `cdr'.

     ASSOCIATION LIST ::=  '( (KEY1 . VALUE1)
                              (KEY2 . VALUE2)
                              (KEY3 . VALUE3)
                              ...
                            )

Association lists are also known, for short, as "alists".

   The structure of an association list is just one example of the
infinite number of possible structures that can be built using pairs
and lists.  As such, the keys and values in an association list can be
manipulated using the general list structure procedures `cons', `car',
`cdr', `set-car!', `set-cdr!' and so on.  However, because association
lists are so useful, Guile also provides specific procedures for
manipulating them.

* Menu:

* Alist Key Equality::
* Adding or Setting Alist Entries::
* Retrieving Alist Entries::
* Removing Alist Entries::
* Sloppy Alist Functions::
* Alist Example::


File: guile.info,  Node: Alist Key Equality,  Next: Adding or Setting Alist Entries,  Up: Association Lists

22.7.2.1 Alist Key Equality
...........................

All of Guile's dedicated association list procedures, apart from
`acons', come in three flavours, depending on the level of equality
that is required to decide whether an existing key in the association
list is the same as the key that the procedure call uses to identify the
required entry.

   * Procedures with "assq" in their name use `eq?' to determine key
     equality.

   * Procedures with "assv" in their name use `eqv?' to determine key
     equality.

   * Procedures with "assoc" in their name use `equal?' to determine
     key equality.

   `acons' is an exception because it is used to build association
lists which do not require their entries' keys to be unique.


File: guile.info,  Node: Adding or Setting Alist Entries,  Next: Retrieving Alist Entries,  Prev: Alist Key Equality,  Up: Association Lists

22.7.2.2 Adding or Setting Alist Entries
........................................

`acons' adds a new entry to an association list and returns the
combined association list.  The combined alist is formed by consing the
new entry onto the head of the alist specified in the `acons' procedure
call.  So the specified alist is not modified, but its contents become
shared with the tail of the combined alist that `acons' returns.

   In the most common usage of `acons', a variable holding the original
association list is updated with the combined alist:

     (set! address-list (acons name address address-list))

   In such cases, it doesn't matter that the old and new values of
`address-list' share some of their contents, since the old value is
usually no longer independently accessible.

   Note that `acons' adds the specified new entry regardless of whether
the alist may already contain entries with keys that are, in some
sense, the same as that of the new entry.  Thus `acons' is ideal for
building alists where there is no concept of key uniqueness.

     (set! task-list (acons 3 "pay gas bill" '()))
     task-list
     =>
     ((3 . "pay gas bill"))

     (set! task-list (acons 3 "tidy bedroom" task-list))
     task-list
     =>
     ((3 . "tidy bedroom") (3 . "pay gas bill"))

   `assq-set!', `assv-set!' and `assoc-set!' are used to add or replace
an entry in an association list where there _is_ a concept of key
uniqueness.  If the specified association list already contains an
entry whose key is the same as that specified in the procedure call,
the existing entry is replaced by the new one.  Otherwise, the new
entry is consed onto the head of the old association list to create the
combined alist.  In all cases, these procedures return the combined
alist.

   `assq-set!' and friends _may_ destructively modify the structure of
the old association list in such a way that an existing variable is
correctly updated without having to `set!' it to the value returned:

     address-list
     =>
     (("mary" . "34 Elm Road") ("james" . "16 Bow Street"))

     (assoc-set! address-list "james" "1a London Road")
     =>
     (("mary" . "34 Elm Road") ("james" . "1a London Road"))

     address-list
     =>
     (("mary" . "34 Elm Road") ("james" . "1a London Road"))

   Or they may not:

     (assoc-set! address-list "bob" "11 Newington Avenue")
     =>
     (("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
      ("james" . "1a London Road"))

     address-list
     =>
     (("mary" . "34 Elm Road") ("james" . "1a London Road"))

   The only safe way to update an association list variable when adding
or replacing an entry like this is to `set!' the variable to the
returned value:

     (set! address-list
           (assoc-set! address-list "bob" "11 Newington Avenue"))
     address-list
     =>
     (("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
      ("james" . "1a London Road"))

   Because of this slight inconvenience, you may find it more
convenient to use hash tables to store dictionary data.  If your
application will not be modifying the contents of an alist very often,
this may not make much difference to you.

   If you need to keep the old value of an association list in a form
independent from the list that results from modification by `acons',
`assq-set!', `assv-set!' or `assoc-set!', use `list-copy' to copy the
old association list before modifying it.

 -- Scheme Procedure: acons key value alist
 -- C Function: scm_acons (key, value, alist)
     Add a new key-value pair to ALIST.  A new pair is created whose
     car is KEY and whose cdr is VALUE, and the pair is consed onto
     ALIST, and the new list is returned.  This function is _not_
     destructive; ALIST is not modified.

 -- Scheme Procedure: assq-set! alist key val
 -- Scheme Procedure: assv-set! alist key value
 -- Scheme Procedure: assoc-set! alist key value
 -- C Function: scm_assq_set_x (alist, key, val)
 -- C Function: scm_assv_set_x (alist, key, val)
 -- C Function: scm_assoc_set_x (alist, key, val)
     Reassociate KEY in ALIST with VALUE: find any existing ALIST entry
     for KEY and associate it with the new VALUE.  If ALIST does not
     contain an entry for KEY, add a new one.  Return the (possibly
     new) alist.

     These functions do not attempt to verify the structure of ALIST,
     and so may cause unusual results if passed an object that is not an
     association list.


File: guile.info,  Node: Retrieving Alist Entries,  Next: Removing Alist Entries,  Prev: Adding or Setting Alist Entries,  Up: Association Lists

22.7.2.3 Retrieving Alist Entries
.................................

`assq', `assv' and `assoc' take an alist and a key as arguments and
return the entry for that key if an entry exists, or `#f' if there is
no entry for that key.  Note that, in the cases where an entry exists,
these procedures return the complete entry, that is `(KEY . VALUE)',
not just the value.

 -- Scheme Procedure: assq key alist
 -- Scheme Procedure: assv key alist
 -- Scheme Procedure: assoc key alist
 -- C Function: scm_assq (key, alist)
 -- C Function: scm_assv (key, alist)
 -- C Function: scm_assoc (key, alist)
     Fetch the entry in ALIST that is associated with KEY.  To decide
     whether the argument KEY matches a particular entry in ALIST,
     `assq' compares keys with `eq?', `assv' uses `eqv?' and `assoc'
     uses `equal?'.  If KEY cannot be found in ALIST (according to
     whichever equality predicate is in use), then return `#f'.  These
     functions return the entire alist entry found (i.e. both the key
     and the value).

   `assq-ref', `assv-ref' and `assoc-ref', on the other hand, take an
alist and a key and return _just the value_ for that key, if an entry
exists.  If there is no entry for the specified key, these procedures
return `#f'.

   This creates an ambiguity: if the return value is `#f', it means
either that there is no entry with the specified key, or that there
_is_ an entry for the specified key, with value `#f'.  Consequently,
`assq-ref' and friends should only be used where it is known that an
entry exists, or where the ambiguity doesn't matter for some other
reason.

 -- Scheme Procedure: assq-ref alist key
 -- Scheme Procedure: assv-ref alist key
 -- Scheme Procedure: assoc-ref alist key
 -- C Function: scm_assq_ref (alist, key)
 -- C Function: scm_assv_ref (alist, key)
 -- C Function: scm_assoc_ref (alist, key)
     Like `assq', `assv' and `assoc', except that only the value
     associated with KEY in ALIST is returned.  These functions are
     equivalent to

          (let ((ent (ASSOCIATOR KEY ALIST)))
            (and ent (cdr ent)))

     where ASSOCIATOR is one of `assq', `assv' or `assoc'.


File: guile.info,  Node: Removing Alist Entries,  Next: Sloppy Alist Functions,  Prev: Retrieving Alist Entries,  Up: Association Lists

22.7.2.4 Removing Alist Entries
...............................

To remove the element from an association list whose key matches a
specified key, use `assq-remove!', `assv-remove!' or `assoc-remove!'
(depending, as usual, on the level of equality required between the key
that you specify and the keys in the association list).

   As with `assq-set!' and friends, the specified alist may or may not
be modified destructively, and the only safe way to update a variable
containing the alist is to `set!' it to the value that `assq-remove!'
and friends return.

     address-list
     =>
     (("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
      ("james" . "1a London Road"))

     (set! address-list (assoc-remove! address-list "mary"))
     address-list
     =>
     (("bob" . "11 Newington Avenue") ("james" . "1a London Road"))

   Note that, when `assq/v/oc-remove!' is used to modify an association
list that has been constructed only using the corresponding
`assq/v/oc-set!', there can be at most one matching entry in the alist,
so the question of multiple entries being removed in one go does not
arise.  If `assq/v/oc-remove!' is applied to an association list that
has been constructed using `acons', or an `assq/v/oc-set!' with a
different level of equality, or any mixture of these, it removes only
the first matching entry from the alist, even if the alist might
contain further matching entries.  For example:

     (define address-list '())
     (set! address-list (assq-set! address-list "mary" "11 Elm Street"))
     (set! address-list (assq-set! address-list "mary" "57 Pine Drive"))
     address-list
     =>
     (("mary" . "57 Pine Drive") ("mary" . "11 Elm Street"))

     (set! address-list (assoc-remove! address-list "mary"))
     address-list
     =>
     (("mary" . "11 Elm Street"))

   In this example, the two instances of the string "mary" are not the
same when compared using `eq?', so the two `assq-set!' calls add two
distinct entries to `address-list'.  When compared using `equal?', both
"mary"s in `address-list' are the same as the "mary" in the
`assoc-remove!' call, but `assoc-remove!' stops after removing the
first matching entry that it finds, and so one of the "mary" entries is
left in place.

 -- Scheme Procedure: assq-remove! alist key
 -- Scheme Procedure: assv-remove! alist key
 -- Scheme Procedure: assoc-remove! alist key
 -- C Function: scm_assq_remove_x (alist, key)
 -- C Function: scm_assv_remove_x (alist, key)
 -- C Function: scm_assoc_remove_x (alist, key)
     Delete the first entry in ALIST associated with KEY, and return
     the resulting alist.


File: guile.info,  Node: Sloppy Alist Functions,  Next: Alist Example,  Prev: Removing Alist Entries,  Up: Association Lists

22.7.2.5 Sloppy Alist Functions
...............................

`sloppy-assq', `sloppy-assv' and `sloppy-assoc' behave like the
corresponding non-`sloppy-' procedures, except that they return `#f'
when the specified association list is not well-formed, where the
non-`sloppy-' versions would signal an error.

   Specifically, there are two conditions for which the non-`sloppy-'
procedures signal an error, which the `sloppy-' procedures handle
instead by returning `#f'.  Firstly, if the specified alist as a whole
is not a proper list:

     (assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
     =>
     ERROR: In procedure assoc in expression (assoc "mary" (quote #)):
     ERROR: Wrong type argument in position 2 (expecting NULLP): "open sesame"
     ABORT: (wrong-type-arg)

     (sloppy-assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
     =>
     #f

Secondly, if one of the entries in the specified alist is not a pair:

     (assoc 2 '((1 . 1) 2 (3 . 9)))
     =>
     ERROR: In procedure assoc in expression (assoc 2 (quote #)):
     ERROR: Wrong type argument in position 2 (expecting CONSP): 2
     ABORT: (wrong-type-arg)

     (sloppy-assoc 2 '((1 . 1) 2 (3 . 9)))
     =>
     #f

   Unless you are explicitly working with badly formed association
lists, it is much safer to use the non-`sloppy-' procedures, because
they help to highlight coding and data errors that the `sloppy-'
versions would silently cover up.

 -- Scheme Procedure: sloppy-assq key alist
 -- C Function: scm_sloppy_assq (key, alist)
     Behaves like `assq' but does not do any error checking.
     Recommended only for use in Guile internals.

 -- Scheme Procedure: sloppy-assv key alist
 -- C Function: scm_sloppy_assv (key, alist)
     Behaves like `assv' but does not do any error checking.
     Recommended only for use in Guile internals.

 -- Scheme Procedure: sloppy-assoc key alist
 -- C Function: scm_sloppy_assoc (key, alist)
     Behaves like `assoc' but does not do any error checking.
     Recommended only for use in Guile internals.


File: guile.info,  Node: Alist Example,  Prev: Sloppy Alist Functions,  Up: Association Lists

22.7.2.6 Alist Example
......................

Here is a longer example of how alists may be used in practice.

     (define capitals '(("New York" . "Albany")
                        ("Oregon"   . "Salem")
                        ("Florida"  . "Miami")))

     ;; What's the capital of Oregon?
     (assoc "Oregon" capitals)       => ("Oregon" . "Salem")
     (assoc-ref capitals "Oregon")   => "Salem"

     ;; We left out South Dakota.
     (set! capitals
           (assoc-set! capitals "South Dakota" "Pierre"))
     capitals
     => (("South Dakota" . "Pierre")
         ("New York" . "Albany")
         ("Oregon" . "Salem")
         ("Florida" . "Miami"))

     ;; And we got Florida wrong.
     (set! capitals
           (assoc-set! capitals "Florida" "Tallahassee"))
     capitals
     => (("South Dakota" . "Pierre")
         ("New York" . "Albany")
         ("Oregon" . "Salem")
         ("Florida" . "Tallahassee"))

     ;; After Oregon secedes, we can remove it.
     (set! capitals
           (assoc-remove! capitals "Oregon"))
     capitals
     => (("South Dakota" . "Pierre")
         ("New York" . "Albany")
         ("Florida" . "Tallahassee"))


File: guile.info,  Node: Hash Tables,  Prev: Association Lists,  Up: Association Lists and Hash Tables

22.7.3 Hash Tables
------------------

Hash tables are dictionaries which offer similar functionality as
association lists: They provide a mapping from keys to values.  The
difference is that association lists need time linear in the size of
elements when searching for entries, whereas hash tables can normally
search in constant time.  The drawback is that hash tables require a
little bit more memory, and that you can not use the normal list
procedures (*note Lists::) for working with them.

* Menu:

* Hash Table Examples::         Demonstration of hash table usage.
* Hash Table Reference::        Hash table procedure descriptions.


File: guile.info,  Node: Hash Table Examples,  Next: Hash Table Reference,  Up: Hash Tables

22.7.3.1 Hash Table Examples
............................

For demonstration purposes, this section gives a few usage examples of
some hash table procedures, together with some explanation what they do.

   First we start by creating a new hash table with 31 slots, and
populate it with two key/value pairs.

     (define h (make-hash-table 31))

     (hashq-create-handle! h 'foo "bar")
     =>
     (foo . "bar")

     (hashq-create-handle! h 'braz "zonk")
     =>
     (braz . "zonk")

     (hashq-create-handle! h 'frob #f)
     =>
     (frob . #f)

   You can get the value for a given key with the procedure
`hashq-ref', but the problem with this procedure is that you cannot
reliably determine whether a key does exists in the table.  The reason
is that the procedure returns `#f' if the key is not in the table, but
it will return the same value if the key is in the table and just
happens to have the value `#f', as you can see in the following
examples.

     (hashq-ref h 'foo)
     =>
     "bar"

     (hashq-ref h 'frob)
     =>
     #f

     (hashq-ref h 'not-there)
     =>
     #f

   Better is to use the procedure `hashq-get-handle', which makes a
distinction between the two cases.  Just like `assq', this procedure
returns a key/value-pair on success, and `#f' if the key is not found.

     (hashq-get-handle h 'foo)
     =>
     (foo . "bar")

     (hashq-get-handle h 'not-there)
     =>
     #f

   There is no procedure for calculating the number of key/value-pairs
in a hash table, but `hash-fold' can be used for doing exactly that.

     (hash-fold (lambda (key value seed) (+ 1 seed)) 0 h)
     =>
     3


File: guile.info,  Node: Hash Table Reference,  Prev: Hash Table Examples,  Up: Hash Tables

22.7.3.2 Hash Table Reference
.............................

Like the association list functions, the hash table functions come in
several varieties: `hashq', `hashv', and `hash'.  The `hashq' functions
use `eq?' to determine whether two keys match.  The `hashv' functions
use `eqv?', and the `hash' functions use `equal?'.

   In each of the functions that follow, the TABLE argument must be a
vector.  The KEY and VALUE arguments may be any Scheme object.

 -- Scheme Procedure: make-hash-table size
     Create a new hash table of SIZE slots.  Note that the number of
     slots does not limit the size of the table, it just tells how large
     the underlying vector will be.  The SIZE should be similar to the
     expected number of elements which will be added to the table, but
     they need not match.  For good performance, it might be a good
     idea to use a prime number as the SIZE.

 -- Scheme Procedure: hashq-ref table key [dflt]
 -- C Function: scm_hashq_ref (table, key, dflt)
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DEFAULT (or `#f'
     if no DEFAULT argument is supplied).  Uses `eq?' for equality
     testing.

 -- Scheme Procedure: hashv-ref table key [dflt]
 -- C Function: scm_hashv_ref (table, key, dflt)
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DEFAULT (or `#f'
     if no DEFAULT argument is supplied).  Uses `eqv?' for equality
     testing.

 -- Scheme Procedure: hash-ref table key [dflt]
 -- C Function: scm_hash_ref (table, key, dflt)
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DEFAULT (or `#f'
     if no DEFAULT argument is supplied).  Uses `equal?' for equality
     testing.

 -- Scheme Procedure: hashq-set! table key val
 -- C Function: scm_hashq_set_x (table, key, val)
     Find the entry in TABLE associated with KEY, and store VALUE
     there. Uses `eq?' for equality testing.

 -- Scheme Procedure: hashv-set! table key val
 -- C Function: scm_hashv_set_x (table, key, val)
     Find the entry in TABLE associated with KEY, and store VALUE
     there. Uses `eqv?' for equality testing.

 -- Scheme Procedure: hash-set! table key val
 -- C Function: scm_hash_set_x (table, key, val)
     Find the entry in TABLE associated with KEY, and store VALUE
     there. Uses `equal?' for equality testing.

 -- Scheme Procedure: hashq-remove! table key
 -- C Function: scm_hashq_remove_x (table, key)
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `eq?' for equality tests.

 -- Scheme Procedure: hashv-remove! table key
 -- C Function: scm_hashv_remove_x (table, key)
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `eqv?' for equality tests.

 -- Scheme Procedure: hash-remove! table key
 -- C Function: scm_hash_remove_x (table, key)
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `equal?' for equality tests.

   The standard hash table functions may be too limited for some
applications.  For example, you may want a hash table to store strings
in a case-insensitive manner, so that references to keys named
"foobar", "FOOBAR" and "FooBaR" will all yield the same item.  Guile
provides you with "extended" hash tables that permit you to specify a
hash function and associator function of your choosing.  The functions
described in the rest of this section can be used to implement such
custom hash table structures.

   If you are unfamiliar with the inner workings of hash tables, then
this facility will probably be a little too abstract for you to use
comfortably.  If you are interested in learning more, see an
introductory textbook on data structures or algorithms for an
explanation of how hash tables are implemented.

 -- Scheme Procedure: hashq key size
 -- C Function: scm_hashq (key, size)
     Determine a hash value for KEY that is suitable for lookups in a
     hash table of size SIZE, where `eq?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.  Note that `hashq' may use internal addresses.  Thus two
     calls to hashq where the keys are `eq?' are not guaranteed to
     deliver the same value if the key object gets garbage collected in
     between.  This can happen, for example with symbols: `(hashq 'foo
     n) (gc) (hashq 'foo n)' may produce two different values, since
     `foo' will be garbage collected.

 -- Scheme Procedure: hashv key size
 -- C Function: scm_hashv (key, size)
     Determine a hash value for KEY that is suitable for lookups in a
     hash table of size SIZE, where `eqv?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.  Note that `(hashv key)' may use internal addresses.  Thus
     two calls to hashv where the keys are `eqv?' are not guaranteed to
     deliver the same value if the key object gets garbage collected in
     between.  This can happen, for example with symbols: `(hashv 'foo
     n) (gc) (hashv 'foo n)' may produce two different values, since
     `foo' will be garbage collected.

 -- Scheme Procedure: hash key size
 -- C Function: scm_hash (key, size)
     Determine a hash value for KEY that is suitable for lookups in a
     hash table of size SIZE, where `equal?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.

 -- Scheme Procedure: hashx-ref hash assoc table key [dflt]
 -- C Function: scm_hashx_ref (hash, assoc, table, key, dflt)
     This behaves the same way as the corresponding `ref' function, but
     uses HASH as a hash function and ASSOC to compare keys.  `hash'
     must be a function that takes two arguments, a key to be hashed
     and a table size.  `assoc' must be an associator function, like
     `assoc', `assq' or `assv'.

     By way of illustration, `hashq-ref table key' is equivalent to
     `hashx-ref hashq assq table key'.

 -- Scheme Procedure: hashx-set! hash assoc table key val
 -- C Function: scm_hashx_set_x (hash, assoc, table, key, val)
     This behaves the same way as the corresponding `set!' function,
     but uses HASH as a hash function and ASSOC to compare keys.
     `hash' must be a function that takes two arguments, a key to be
     hashed and a table size.  `assoc' must be an associator function,
     like `assoc', `assq' or `assv'.

     By way of illustration, `hashq-set! table key' is equivalent to
     `hashx-set!  hashq assq table key'.

 -- Scheme Procedure: hashq-get-handle table key
 -- C Function: scm_hashq_get_handle (table, key)
     This procedure returns the `(key . value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `eq?' for equality testing.

 -- Scheme Procedure: hashv-get-handle table key
 -- C Function: scm_hashv_get_handle (table, key)
     This procedure returns the `(key . value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `eqv?' for equality testing.

 -- Scheme Procedure: hash-get-handle table key
 -- C Function: scm_hash_get_handle (table, key)
     This procedure returns the `(key . value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `equal?' for equality testing.

 -- Scheme Procedure: hashx-get-handle hash assoc table key
 -- C Function: scm_hashx_get_handle (hash, assoc, table, key)
     This behaves the same way as the corresponding `-get-handle'
     function, but uses HASH as a hash function and ASSOC to compare
     keys.  `hash' must be a function that takes two arguments, a key
     to be hashed and a table size.  `assoc' must be an associator
     function, like `assoc', `assq' or `assv'.

 -- Scheme Procedure: hashq-create-handle! table key init
 -- C Function: scm_hashq_create_handle_x (table, key, init)
     This function looks up KEY in TABLE and returns its handle.  If
     KEY is not already present, a new handle is created which
     associates KEY with INIT.

 -- Scheme Procedure: hashv-create-handle! table key init
 -- C Function: scm_hashv_create_handle_x (table, key, init)
     This function looks up KEY in TABLE and returns its handle.  If
     KEY is not already present, a new handle is created which
     associates KEY with INIT.

 -- Scheme Procedure: hash-create-handle! table key init
 -- C Function: scm_hash_create_handle_x (table, key, init)
     This function looks up KEY in TABLE and returns its handle.  If
     KEY is not already present, a new handle is created which
     associates KEY with INIT.

 -- Scheme Procedure: hashx-create-handle! hash assoc table key init
 -- C Function: scm_hashx_create_handle_x (hash, assoc, table, key,
          init)
     This behaves the same way as the corresponding `-create-handle'
     function, but uses HASH as a hash function and ASSOC to compare
     keys.  `hash' must be a function that takes two arguments, a key
     to be hashed and a table size.  `assoc' must be an associator
     function, like `assoc', `assq' or `assv'.

 -- Scheme Procedure: hash-fold proc init table
 -- C Function: scm_hash_fold (proc, init, table)
     An iterator over hash-table elements.  Accumulates and returns a
     result by applying PROC successively.  The arguments to PROC are
     "(key value prior-result)" where key and value are successive
     pairs from the hash table TABLE, and prior-result is either INIT
     (for the first application of PROC) or the return value of the
     previous application of PROC.  For example, `(hash-fold acons '()
     tab)' will convert a hash table into an a-list of key-value pairs.


File: guile.info,  Node: Procedures and Macros,  Next: Utility Functions,  Prev: Compound Data Types,  Up: Top

23 Procedures and Macros
************************

* Menu:

* Lambda::                      Basic procedure creation using lambda.
* Optional Arguments::          Handling keyword, optional and rest arguments.
* Procedure Properties::        Procedure properties and meta-information.
* Procedures with Setters::     Procedures with setters.
* Macros::                      Lisp style macro definitions.
* Syntax Rules::                Support for R5RS `syntax-rules'.
* Syntax Case::                 Support for the `syntax-case' system.
* Internal Macros::             Guile's internal representation.


File: guile.info,  Node: Lambda,  Next: Optional Arguments,  Up: Procedures and Macros

23.1 Lambda: Basic Procedure Creation
=====================================

A `lambda' expression evaluates to a procedure.  The environment which
is in effect when a `lambda' expression is evaluated is enclosed in the
newly created procedure, this is referred to as a "closure" (*note
About Closure::).

   When a procedure created by `lambda' is called with some actual
arguments, the environment enclosed in the procedure is extended by
binding the variables named in the formal argument list to new locations
and storing the actual arguments into these locations.  Then the body of
the `lambda' expression is evaluation sequentially.  The result of the
last expression in the procedure body is then the result of the
procedure invocation.

   The following examples will show how procedures can be created using
`lambda', and what you can do with these procedures.

     (lambda (x) (+ x x))       => a procedure
     ((lambda (x) (+ x x)) 4)   => 8

   The fact that the environment in effect when creating a procedure is
enclosed in the procedure is shown with this example:

     (define add4
       (let ((x 4))
         (lambda (y) (+ x y))))
     (add4 6)                   => 10

 -- syntax: lambda formals body
     FORMALS should be a formal argument list as described in the
     following table.

    `(VARIABLE1 ...)'
          The procedure takes a fixed number of arguments; when the
          procedure is called, the arguments will be stored into the
          newly created location for the formal variables.

    `VARIABLE'
          The procedure takes any number of arguments; when the
          procedure is called, the sequence of actual arguments will
          converted into a list and stored into the newly created
          location for the formal variable.

    `(VARIABLE1 ... VARIABLEN . VARIABLEN+1)'
          If a space-delimited period precedes the last variable, then
          the procedure takes N or more variables where N is the number
          of formal arguments before the period.  There must be at
          least one argument before the period.  The first N actual
          arguments will be stored into the newly allocated locations
          for the first N formal arguments and the sequence of the
          remaining actual arguments is converted into a list and the
          stored into the location for the last formal argument.  If
          there are exactly N actual arguments, the empty list is
          stored into the location of the last formal argument.

     BODY is a sequence of Scheme expressions which are evaluated in
     order when the procedure is invoked.


File: guile.info,  Node: Optional Arguments,  Next: Procedure Properties,  Prev: Lambda,  Up: Procedures and Macros

23.2 Optional Arguments
=======================

Scheme procedures, as defined in R5RS, can either handle a fixed number
of actual arguments, or a fixed number of actual arguments followed by
arbitrarily many additional arguments.  Writing procedures of variable
arity can be useful, but unfortunately, the syntactic means for handling
argument lists of varying length is a bit inconvenient.  It is possible
to give names to the fixed number of argument, but the remaining
(optional) arguments can be only referenced as a list of values (*note
Lambda::).

   Guile comes with the module `(ice-9 optargs)', which makes using
optional arguments much more convenient.  In addition, this module
provides syntax for handling keywords in argument lists (*note
Keywords::).

   Before using any of the procedures or macros defined in this section,
you have to load the module `(ice-9 optargs)' with the statement:

     (use-modules (ice-9 optargs))

* Menu:

* let-optional Reference::      Locally binding optional arguments.
* let-keywords Reference::      Locally binding keywords arguments.
* lambda* Reference::           Creating advanced argument handling procedures.
* define* Reference::           Defining procedures and macros.


File: guile.info,  Node: let-optional Reference,  Next: let-keywords Reference,  Up: Optional Arguments

23.2.1 let-optional Reference
-----------------------------

The syntax `let-optional' and `let-optional*' are for destructuring
rest argument lists and giving names to the various list elements.
`let-optional' binds all variables simultaneously, while
`let-optional*' binds them sequentially, consistent with `let' and
`let*' (*note Local Bindings::).

 -- library syntax: let-optional rest-arg (binding ...) expr ...
 -- library syntax: let-optional* rest-arg (binding ...) expr ...
     These two macros give you an optional argument interface that is
     very "Schemey" and introduces no fancy syntax. They are compatible
     with the scsh macros of the same name, but are slightly extended.
     Each of BINDING may be of one of the forms VAR or `(VAR
     DEFAULT-VALUE)'. REST-ARG should be the rest-argument of the
     procedures these are used from.  The items in REST-ARG are
     sequentially bound to the variable names are given. When REST-ARG
     runs out, the remaining vars are bound either to the default
     values or `#f' if no default value was specified. REST-ARG remains
     bound to whatever may have been left of REST-ARG.

     After binding the variables, the expressions EXPR ... are
     evaluated in order.


File: guile.info,  Node: let-keywords Reference,  Next: lambda* Reference,  Prev: let-optional Reference,  Up: Optional Arguments

23.2.2 let-keywords Reference
-----------------------------

`let-keywords' and `let-keywords*' are used for extracting values from
argument lists which use keywords instead of argument position for
binding local variables to argument values.

   `let-keywords' binds all variables simultaneously, while
`let-keywords*' binds them sequentially, consistent with `let' and
`let*' (*note Local Bindings::).

 -- library syntax: let-keywords rest-arg allow-other-keys? (binding
          ...) expr ...
 -- library syntax: let-keywords rest-arg allow-other-keys? (binding
          ...) expr ...
     These macros pick out keyword arguments from REST-ARG, but do not
     modify it.  This is consistent at least with Common Lisp, which
     duplicates keyword arguments in the rest argument. More
     explanation of what keyword arguments in a lambda list look like
     can be found below in the documentation for `lambda*'  (*note
     lambda* Reference::).  BINDINGs can have the same form as for
     `let-optional'. If ALLOW-OTHER-KEYS? is false, an error will be
     thrown if anything that looks like a keyword argument but does not
     match a known keyword parameter will result in an error.

     After binding the variables, the expressions EXPR ... are
     evaluated in order.


File: guile.info,  Node: lambda* Reference,  Next: define* Reference,  Prev: let-keywords Reference,  Up: Optional Arguments

23.2.3 lambda* Reference
------------------------

When using optional and keyword argument lists, using `lambda' for
creating procedures and using `let-optional' or `let-keywords' is a bit
lengthy.  Therefore, `lambda*' is provided, which combines the features
of those macros into a single convenient syntax.

   For quick reference, here is the syntax of the formal argument list
for `lambda*' (brackets are used to indicate grouping only):

     ext-param-list ::= [identifier]* [#:optional [ext-var-decl]+]?
       [#:key [ext-var-decl]+ [#:allow-other-keys]?]?
       [[#:rest identifier]|[. identifier]]?

     ext-var-decl ::= identifier | ( identifier expression )

   The characters `*', `+' and `?' are not to be taken literally; they
mean respectively, zero or more occurrences, one or more occurrences,
and one or zero occurrences.

 -- library syntax: lambda* formals body
     `lambda*' creates a procedure that takes optional arguments. These
     are specified by putting them inside brackets at the end of the
     parameter list, but before any dotted rest argument. For example,

          (lambda* (a b #:optional c d . e) '())

     creates a procedure with fixed arguments A and B, optional
     arguments C and D, and rest argument E. If the optional arguments
     are omitted in a call, the variables for them are bound to `#f'.

     `lambda*' can also take keyword arguments. For example, a procedure
     defined like this:

          (lambda* (#:key xyzzy larch) '())

     can be called with any of the argument lists `(#:xyzzy 11)'
     `(#:larch 13)' `(#:larch 42 #:xyzzy 19)' `()'. Whichever arguments
     are given as keywords are bound to values.

     Optional and keyword arguments can also be given default values
     which they take on when they are not present in a call, by giving a
     two-item list in place of an optional argument, for example in:

          (lambda* (foo #:optional (bar 42) #:key (baz 73))
               (list foo bar baz))

     FOO is a fixed argument, BAR is an optional argument with default
     value 42, and baz is a keyword argument with default value 73.
     Default value expressions are not evaluated unless they are needed
     and until the procedure is called.

     `lambda*' also supports two more special parameter list keywords.

     `lambda*'-defined procedures now throw an error by default if a
     keyword other than one of those specified is found in the actual
     passed arguments. However, specifying `#:allow-other-keys'
     immediately after the keyword argument declarations restores the
     previous behavior of ignoring unknown keywords.  `lambda*' also now
     guarantees that if the same keyword is passed more than once, the
     last one passed is the one that takes effect. For example,

          ((lambda* (#:key (heads 0) (tails 0)) (display (list heads tails)))
              #:heads 37 #:tails 42 #:heads 99)

     would result in (99 47) being displayed.

     `#:rest' is also now provided as a synonym for the dotted syntax
     rest argument. The argument lists `(a . b)' and `(a #:rest b)' are
     equivalent in all respects to `lambda*'. This is provided for more
     similarity to DSSSL, MIT-Scheme and Kawa among others, as well as
     for refugees from other Lisp dialects.


File: guile.info,  Node: define* Reference,  Prev: lambda* Reference,  Up: Optional Arguments

23.2.4 define* Reference
------------------------

Just like `define' has a shorthand notation for defining procedures
(*note Lambda Alternatives::), `define*' is provided as an abbreviation
of the combination of `define' and `lambda*'.

   `define*-public' is the `lambda*' version of `define-public';
`defmacro*' and `defmacro*-public' exist for defining macros with the
improved argument list handling possibilities.  The `-public' versions
not only define the procedures/macros, but also export them from the
current module.

 -- library syntax: define* formals body
 -- library syntax: define*-public formals body
     `define*' and `define*-public' support optional arguments with a
     similar syntax to `lambda*'. They also support arbitrary-depth
     currying, just like Guile's define. Some examples:

          (define* (x y #:optional a (z 3) #:key w . u)
             (display (list y z u)))
     defines a procedure `x' with a fixed argument Y, an optional
     argument A, another optional argument Z with default value 3, a
     keyword argument W, and a rest argument U.

          (define-public* ((foo #:optional bar) #:optional baz) '())

     This illustrates currying. A procedure `foo' is defined, which,
     when called with an optional argument BAR, returns a procedure
     that takes an optional argument BAZ.

     Of course, `define*[-public]' also supports `#:rest' and
     `#:allow-other-keys' in the same way as `lambda*'.

 -- library syntax: defmacro* name formals body
 -- library syntax: defmacro*-public name formals body
     These are just like `defmacro' and `defmacro-public' except that
     they take `lambda*'-style extended parameter lists, where
     `#:optional', `#:key', `#:allow-other-keys' and `#:rest' are
     allowed with the usual semantics. Here is an example of a macro
     with an optional argument:

          (defmacro* transmorgify (a #:optional b)
              (a 1))


File: guile.info,  Node: Procedure Properties,  Next: Procedures with Setters,  Prev: Optional Arguments,  Up: Procedures and Macros

23.3 Procedure Properties and Meta-information
==============================================

Procedures always have attached the environment in which they were
created and information about how to apply them to actual arguments.  In
addition to that, properties and meta-information can be stored with
procedures.  The procedures in this section can be used to test whether
a given procedure satisfies a condition; and to access and set a
procedure's property.

   The first group of procedures are predicates to test whether a Scheme
object is a procedure, or a special procedure, respectively.
`procedure?' is the most general predicates, it returns `#t' for any
kind of procedure.  `closure?' does not return `#t' for primitive
procedures, and `thunk?' only returns `#t' for procedures which do not
accept any arguments.

 -- Scheme Procedure: procedure? obj
 -- C Function: scm_procedure_p (obj)
     Return `#t' if OBJ is a procedure.

 -- Scheme Procedure: closure? obj
 -- C Function: scm_closure_p (obj)
     Return `#t' if OBJ is a closure.

 -- Scheme Procedure: thunk? obj
 -- C Function: scm_thunk_p (obj)
     Return `#t' if OBJ is a thunk.

   Procedure properties are general properties to be attached to
procedures.  These can be the name of a procedure or other relevant
information, such as debug hints.

 -- Scheme Procedure: procedure-name proc
 -- C Function: scm_procedure_name (proc)
     Return the name of the procedure PROC

 -- Scheme Procedure: procedure-source proc
 -- C Function: scm_procedure_source (proc)
     Return the source of the procedure PROC.

 -- Scheme Procedure: procedure-environment proc
 -- C Function: scm_procedure_environment (proc)
     Return the environment of the procedure PROC.

 -- Scheme Procedure: procedure-properties proc
 -- C Function: scm_procedure_properties (proc)
     Return OBJ's property list.

 -- Scheme Procedure: procedure-property obj key
 -- C Function: scm_procedure_property (obj, key)
     Return the property of OBJ with name KEY.

 -- Scheme Procedure: set-procedure-properties! proc alist
 -- C Function: scm_set_procedure_properties_x (proc, alist)
     Set OBJ's property list to ALIST.

 -- Scheme Procedure: set-procedure-property! obj key value
 -- C Function: scm_set_procedure_property_x (obj, key, value)
     In OBJ's property list, set the property named KEY to VALUE.

   Documentation for a procedure can be accessed with the procedure
`procedure-documentation'.

 -- Scheme Procedure: procedure-documentation proc
 -- C Function: scm_procedure_documentation (proc)
     Return the documentation string associated with `proc'.  By
     convention, if a procedure contains more than one expression and
     the first expression is a string constant, that string is assumed
     to contain documentation for that procedure.

   Source properties are properties which are related to the source
code of a procedure, such as the line and column numbers, the file name
etc.

 -- Scheme Procedure: set-source-properties! obj plist
 -- C Function: scm_set_source_properties_x (obj, plist)
     Install the association list PLIST as the source property list for
     OBJ.

 -- Scheme Procedure: set-source-property! obj key datum
 -- C Function: scm_set_source_property_x (obj, key, datum)
     Set the source property of object OBJ, which is specified by KEY
     to DATUM.  Normally, the key will be a symbol.

 -- Scheme Procedure: source-properties obj
 -- C Function: scm_source_properties (obj)
     Return the source property association list of OBJ.

 -- Scheme Procedure: source-property obj key
 -- C Function: scm_source_property (obj, key)
     Return the source property specified by KEY from OBJ's source
     property list.


File: guile.info,  Node: Procedures with Setters,  Next: Macros,  Prev: Procedure Properties,  Up: Procedures and Macros

23.4 Procedures with Setters
============================

A "procedure with setter" is a special kind of procedure which normally
behaves like any accessor procedure, that is a procedure which accesses
a data structure.  The difference is that this kind of procedure has a
so-called "setter" attached, which is a procedure for storing something
into a data structure.

   Procedures with setters are treated specially when the procedure
appears in the special form `set!' (REFFIXME).  How it works is best
shown by example.

   Suppose we have a procedure called `foo-ref', which accepts two
arguments, a value of type `foo' and an integer.  The procedure returns
the value stored at the given index in the `foo' object.  Let `f' be a
variable containing such a `foo' data structure.(1)

     (foo-ref f 0)       => bar
     (foo-ref f 1)       => braz

   Also suppose that a corresponding setter procedure called `foo-set!'
does exist.

     (foo-set! f 0 'bla)
     (foo-ref f 0)       => bla

   Now we could create a new procedure called `foo', which is a
procedure with setter, by calling `make-procedure-with-setter' with the
accessor and setter procedures `foo-ref' and `foo-set!'.  Let us call
this new procedure `foo'.

     (define foo (make-procedure-with-setter foo-ref foo-set!))

   `foo' can from now an be used to either read from the data structure
stored in `f', or to write into the structure.

     (set! (foo f 0) 'dum)
     (foo f 0)          => dum

 -- Scheme Procedure: make-procedure-with-setter procedure setter
 -- C Function: scm_make_procedure_with_setter (procedure, setter)
     Create a new procedure which behaves like PROCEDURE, but with the
     associated setter SETTER.

 -- Scheme Procedure: procedure-with-setter? obj
 -- C Function: scm_procedure_with_setter_p (obj)
     Return `#t' if OBJ is a procedure with an associated setter
     procedure.

 -- Scheme Procedure: procedure proc
 -- C Function: scm_procedure (proc)
     Return the procedure of PROC, which must be either a procedure
     with setter, or an operator struct.

 -- Scheme Procedure: setter proc
     Return the setter of PROC, which must be either a procedure with
     setter or an operator struct.

   ---------- Footnotes ----------

   (1) Working definitions would be:
     (define foo-ref vector-ref)
     (define foo-set! vector-set!)
     (define f (make-vector 2 #f))


File: guile.info,  Node: Macros,  Next: Syntax Rules,  Prev: Procedures with Setters,  Up: Procedures and Macros

23.5 Lisp Style Macro Definitions
=================================

Macros are objects which cause the expression that they appear in to be
transformed in some way _before_ being evaluated.  In expressions that
are intended for macro transformation, the identifier that names the
relevant macro must appear as the first element, like this:

     (MACRO-NAME MACRO-ARGS ...)

   In Lisp-like languages, the traditional way to define macros is very
similar to procedure definitions.  The key differences are that the
macro definition body should return a list that describes the
transformed expression, and that the definition is marked as a macro
definition (rather than a procedure definition) by the use of a
different definition keyword: in Lisp, `defmacro' rather than `defun',
and in Scheme, `define-macro' rather than `define'.

   Guile supports this style of macro definition using both `defmacro'
and `define-macro'.  The only difference between them is how the macro
name and arguments are grouped together in the definition:

     (defmacro NAME (ARGS ...) BODY ...)

is the same as

     (define-macro (NAME ARGS ...) BODY ...)

The difference is analogous to the corresponding difference between
Lisp's `defun' and Scheme's `define'.

   `false-if-exception', from the `boot-9.scm' file in the Guile
distribution, is a good example of macro definition using `defmacro':

     (defmacro false-if-exception (expr)
       `(catch #t
               (lambda () ,expr)
               (lambda args #f)))

The effect of this definition is that expressions beginning with the
identifier `false-if-exception' are automatically transformed into a
`catch' expression following the macro definition specification.  For
example:

     (false-if-exception (open-input-file "may-not-exist"))
     ==
     (catch #t
            (lambda () (open-input-file "may-not-exist"))
            (lambda args #f))


File: guile.info,  Node: Syntax Rules,  Next: Syntax Case,  Prev: Macros,  Up: Procedures and Macros

23.6 The R5RS `syntax-rules' System
===================================

R5RS defines an alternative system for macro and syntax transformations
using the keywords `define-syntax', `let-syntax', `letrec-syntax' and
`syntax-rules'.

   The main difference between the R5RS system and the traditional
macros of the previous section is how the transformation is specified.
In R5RS, rather than permitting a macro definition to return an
arbitrary expression, the transformation is specified in a pattern
language that

   * does not require complicated quoting and extraction of components
     of the source expression using `caddr' etc.

   * is designed such that the bindings associated with identifiers in
     the transformed expression are well defined, and such that it is
     impossible for the transformed expression to construct new
     identifiers.

The last point is commonly referred to as being "hygienic": the R5RS
`syntax-case' system provides "hygienic macros".

   For example, the R5RS pattern language for the `false-if-exception'
example of the previous section looks like this:

     (syntax-rules ()
       ((_ expr)
        (catch #t
               (lambda () expr)
               (lambda args #f))))

   In Guile, the `syntax-rules' system is provided by the `(ice-9
syncase)' module.  To make these facilities available in your code,
include the expression `(use-syntax (ice-9 syncase))' (*note Using
Guile Modules::) before the first usage of `define-syntax' etc.  If you
are writing a Scheme module, you can alternatively include the form
`#:use-syntax (ice-9 syncase)' in your `define-module' declaration
(*note Creating Guile Modules::).

* Menu:

* Pattern Language::            The `syntax-rules' pattern language.
* Define-Syntax::               Top level syntax definitions.
* Let-Syntax::                  Local syntax definitions.


File: guile.info,  Node: Pattern Language,  Next: Define-Syntax,  Up: Syntax Rules

23.6.1 The `syntax-rules' Pattern Language
------------------------------------------


File: guile.info,  Node: Define-Syntax,  Next: Let-Syntax,  Prev: Pattern Language,  Up: Syntax Rules

23.6.2 Top Level Syntax Definitions
-----------------------------------

define-syntax:  The gist is

   (define-syntax <keyword> <transformer-spec>)

   makes the <keyword> into a macro so that

   (<keyword> ...)

   expands at _compile_ or _read_ time (i.e. before any evaluation
begins) into some expression that is given by the <transformer-spec>.


File: guile.info,  Node: Let-Syntax,  Prev: Define-Syntax,  Up: Syntax Rules

23.6.3 Local Syntax Definitions
-------------------------------


File: guile.info,  Node: Syntax Case,  Next: Internal Macros,  Prev: Syntax Rules,  Up: Procedures and Macros

23.7 Support for the `syntax-case' System
=========================================


File: guile.info,  Node: Internal Macros,  Prev: Syntax Case,  Up: Procedures and Macros

23.8 Internal Representation of Macros and Syntax
=================================================

Internally, Guile uses three different flavors of macros.  The three
flavors are called "acro" (or "syntax"), "macro" and "mmacro".

   Given the expression

     (foo ...)

with `foo' being some flavor of macro, one of the following things will
happen when the expression is evaluated.

   * When `foo' has been defined to be an "acro", the procedure used in
     the acro definition of `foo' is passed the whole expression and
     the current lexical environment, and whatever that procedure
     returns is the value of evaluating the expression.  You can think
     of this a procedure that receives its argument as an unevaluated
     expression.

   * When `foo' has been defined to be a "macro", the procedure used in
     the macro definition of `foo' is passed the whole expression and
     the current lexical environment, and whatever that procedure
     returns is evaluated again.  That is, the procedure should return
     a valid Scheme expression.

   * When `foo' has been defined to be a "mmacro", the procedure used
     in the mmacro definition of `foo' is passed the whole expression
     and the current lexical environment, and whatever that procedure
     returns replaces the original expression.  Evaluation then starts
     over from the new expression that has just been returned.

   The key difference between a "macro" and a "mmacro" is that the
expression returned by a "mmacro" procedure is remembered (or
"memoized") so that the expansion does not need to be done again next
time the containing code is evaluated.

   The primitives `procedure->syntax', `procedure->macro' and
`procedure->memoizing-macro' are used to construct acros, macros and
mmacros respectively.  However, if you do not have a very special
reason to use one of these primitives, you should avoid them: they are
very specific to Guile's current implementation and therefore likely to
change.  Use `defmacro', `define-macro' (*note Macros::) or
`define-syntax' (*note Syntax Rules::) instead.  (In low level terms,
`defmacro', `define-macro' and `define-syntax' are all implemented as
mmacros.)

 -- Scheme Procedure: procedure->syntax code
 -- C Function: scm_makacro (code)
     Return a macro which, when a symbol defined to this value appears
     as the first symbol in an expression, returns the result of
     applying CODE to the expression and the environment.

 -- Scheme Procedure: procedure->macro code
 -- C Function: scm_makmacro (code)
     Return a macro which, when a symbol defined to this value appears
     as the first symbol in an expression, evaluates the result of
     applying CODE to the expression and the environment.  For example:

          (define trace
            (procedure->macro
              (lambda (x env)
                `(set! ,(cadr x) (tracef ,(cadr x) ',(cadr x))))))

          (trace foo)
          ==
          (set! foo (tracef foo 'foo)).

 -- Scheme Procedure: procedure->memoizing-macro code
 -- C Function: scm_makmmacro (code)
     Return a macro which, when a symbol defined to this value appears
     as the first symbol in an expression, evaluates the result of
     applying CODE to the expression and the environment.
     `procedure->memoizing-macro' is the same as `procedure->macro',
     except that the expression returned by CODE replaces the original
     macro expression in the memoized form of the containing code.

   In the following primitives, "acro" flavor macros are referred to as
"syntax transformers".

 -- Scheme Procedure: macro? obj
 -- C Function: scm_macro_p (obj)
     Return `#t' if OBJ is a regular macro, a memoizing macro or a
     syntax transformer.

 -- Scheme Procedure: macro-type m
 -- C Function: scm_macro_type (m)
     Return one of the symbols `syntax', `macro' or `macro!', depending
     on whether M is a syntax transformer, a regular macro, or a
     memoizing macro, respectively.  If M is not a macro, `#f' is
     returned.

 -- Scheme Procedure: macro-name m
 -- C Function: scm_macro_name (m)
     Return the name of the macro M.

 -- Scheme Procedure: macro-transformer m
 -- C Function: scm_macro_transformer (m)
     Return the transformer of the macro M.

 -- Scheme Procedure: cons-source xorig x y
 -- C Function: scm_cons_source (xorig, x, y)
     Create and return a new pair whose car and cdr are X and Y.  Any
     source properties associated with XORIG are also associated with
     the new pair.


File: guile.info,  Node: Utility Functions,  Next: Binding Constructs,  Prev: Procedures and Macros,  Up: Top

24 General Utility Functions
****************************

This chapter contains information about procedures which are not cleanly
tied to a specific data type.  Because of their wide range of
applications, they are collected in a "utility" chapter.

* Menu:

* Equality::                    When are two values `the same'?
* Object Properties::           A modern interface to object properties.
* Sorting::                     Sort utility procedures.
* Copying::                     Copying deep structures.
* General Conversion::          Converting objects to strings.
* Hooks::                       User-customizable event lists.


File: guile.info,  Node: Equality,  Next: Object Properties,  Up: Utility Functions

24.1 Equality
=============

Three different kinds of "sameness" are defined in Scheme.

   * Two values can refer to exactly the same object.

   * Two objects can have the same "value".

   * Two objects can be structurally equivalent.

   The differentiation between these three kinds is important, because
determining whether two values are the same objects is very efficient,
while determining structural equivalence can be quite expensive
(consider comparing two very long lists).  Therefore, three different
procedures for testing for equality are provided, which correspond to
the three kinds of "sameness" defined above.

 -- Scheme Procedure: eq? x y
     Return `#t' iff X references the same object as Y.  `eq?' is
     similar to `eqv?' except that in some cases it is capable of
     discerning distinctions finer than those detectable by `eqv?'.

 -- Scheme Procedure: eqv? x y
     The `eqv?' procedure defines a useful equivalence relation on
     objects.  Briefly, it returns `#t' if X and Y should normally be
     regarded as the same object.  This relation is left slightly open
     to interpretation, but works for comparing immediate integers,
     characters, and inexact numbers.

 -- Scheme Procedure: equal? x y
     Return `#t' iff X and Y are recursively `eqv?' equivalent.
     `equal?' recursively compares the contents of pairs, vectors, and
     strings, applying `eqv?' on other objects such as numbers and
     symbols.  A rule of thumb is that objects are generally `equal?'
     if they print the same.  `equal?' may fail to terminate if its
     arguments are circular data structures.


File: guile.info,  Node: Object Properties,  Next: Sorting,  Prev: Equality,  Up: Utility Functions

24.2 Object Properties
======================

It's often useful to associate a piece of additional information with a
Scheme object even though that object does not have a dedicated slot
available in which the additional information could be stored.  Object
properties allow you to do just that.

   An object property is most commonly used to associate one kind of
additional information with each instance of a class of similar Scheme
objects.  For example, all procedures have a `name' property, which
stores the name of the variable in which the procedure was stored by a
`define' expression, or `#f' if the procedure wasn't created by that
kind of expression.

   Guile's representation of an object property is a
procedure-with-setter (*note Procedures with Setters::) that can be
used with the generalized form of `set!' (REFFIXME) to set and retrieve
that property for any Scheme object.  So, setting a property looks like
this:

     (set! (my-property obj1) value-for-obj1)
     (set! (my-property obj2) value-for-obj2)

And retrieving values of the same property looks like this:

     (my-property obj1)
     =>
     value-for-obj1

     (my-property obj2)
     =>
     value-for-obj2

   To create an object property in the first place, use the
`make-object-property' procedure:

     (define my-property (make-object-property))

 -- Scheme Procedure: make-object-property
     Create and return an object property.  An object property is a
     procedure-with-setter that can be called in two ways.  `(set!
     (PROPERTY OBJ) VAL)' sets OBJ's PROPERTY to VAL.  `(PROPERTY OBJ)'
     returns the current setting of OBJ's PROPERTY.

   A single object property created by `make-object-property' can
associate distinct property values with all Scheme values that are
distinguishable by `eq?' (including, for example, integers).

   Internally, object properties are implemented using a weak key hash
table.  This means that, as long as a Scheme value with property values
is protected from garbage collection, its property values are also
protected.  When the Scheme value is collected, its entry in the
property table is removed and so the (ex-) property values are no longer
protected by the table.

* Menu:

* Property Primitives::         Low level property implementation.
* Old-fashioned Properties::    An older approach to properties.


File: guile.info,  Node: Property Primitives,  Next: Old-fashioned Properties,  Up: Object Properties

24.2.1 Low Level Property Implementation.
-----------------------------------------

 -- Scheme Procedure: primitive-make-property not_found_proc
 -- C Function: scm_primitive_make_property (not_found_proc)
     Create a "property token" that can be used with
     `primitive-property-ref' and `primitive-property-set!'.  See
     `primitive-property-ref' for the significance of NOT_FOUND_PROC.

 -- Scheme Procedure: primitive-property-ref prop obj
 -- C Function: scm_primitive_property_ref (prop, obj)
     Return the property PROP of OBJ.  When no value has yet been
     associated with PROP and OBJ, call NOT-FOUND-PROC instead (see
     `primitive-make-property') and use its return value.  That value
     is also associated with OBJ via `primitive-property-set!'.  When
     NOT-FOUND-PROC is `#f', use `#f' as the default value of PROP.

 -- Scheme Procedure: primitive-property-set! prop obj val
 -- C Function: scm_primitive_property_set_x (prop, obj, val)
     Associate CODE with PROP and OBJ.

 -- Scheme Procedure: primitive-property-del! prop obj
 -- C Function: scm_primitive_property_del_x (prop, obj)
     Remove any value associated with PROP and OBJ.


File: guile.info,  Node: Old-fashioned Properties,  Prev: Property Primitives,  Up: Object Properties

24.2.2 An Older Approach to Properties
--------------------------------------

Traditionally, Lisp systems provide a different object property
interface to that provided by `make-object-property', in which the
object property that is being set or retrieved is indicated by a symbol.

   Guile includes this older kind of interface as well, but it may well
be removed in a future release, as it is less powerful than
`make-object-property' and so increases the size of the Guile library
for no benefit.  (And it is trivial to write a compatibility layer in
Scheme.)

 -- Scheme Procedure: object-properties obj
 -- C Function: scm_object_properties (obj)
     Return OBJ's property list.

 -- Scheme Procedure: set-object-properties! obj alist
 -- C Function: scm_set_object_properties_x (obj, alist)
     Set OBJ's property list to ALIST.

 -- Scheme Procedure: object-property obj key
 -- C Function: scm_object_property (obj, key)
     Return the property of OBJ with name KEY.

 -- Scheme Procedure: set-object-property! obj key value
 -- C Function: scm_set_object_property_x (obj, key, value)
     In OBJ's property list, set the property named KEY to VALUE.


File: guile.info,  Node: Sorting,  Next: Copying,  Prev: Object Properties,  Up: Utility Functions

24.3 Sorting
============

Sorting is very important in computer programs.  Therefore, Guile comes
with several sorting procedures built-in.  As always, procedures with
names ending in `!' are side-effecting, that means that they may modify
their parameters in order to produce their results.

   The first group of procedures can be used to merge two lists (which
must be already sorted on their own) and produce sorted lists containing
all elements of the input lists.

 -- Scheme Procedure: merge alist blist less
 -- C Function: scm_merge (alist, blist, less)
     Merge two already sorted lists into one.  Given two lists ALIST
     and BLIST, such that `(sorted? alist less?)' and `(sorted? blist
     less?)', return a new list in which the elements of ALIST and
     BLIST have been stably interleaved so that `(sorted? (merge alist
     blist less?) less?)'.  Note:  this does _not_ accept vectors.

 -- Scheme Procedure: merge! alist blist less
 -- C Function: scm_merge_x (alist, blist, less)
     Takes two lists ALIST and BLIST such that `(sorted? alist less?)'
     and `(sorted? blist less?)' and returns a new list in which the
     elements of ALIST and BLIST have been stably interleaved so that
     `(sorted? (merge alist blist less?) less?)'.  This is the
     destructive variant of `merge' Note:  this does _not_ accept
     vectors.

   The following procedures can operate on sequences which are either
vectors or list.  According to the given arguments, they return sorted
vectors or lists, respectively.  The first of the following procedures
determines whether a sequence is already sorted, the other sort a given
sequence.  The variants with names starting with `stable-' are special
in that they maintain a special property of the input sequences: If two
or more elements are the same according to the comparison predicate,
they are left in the same order as they appeared in the input.

 -- Scheme Procedure: sorted? items less
 -- C Function: scm_sorted_p (items, less)
     Return `#t' iff ITEMS is a list or a vector such that for all 1 <=
     i <= m, the predicate LESS returns true when applied to all
     elements i - 1 and i

 -- Scheme Procedure: sort items less
 -- C Function: scm_sort (items, less)
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  This is not a stable
     sort.

 -- Scheme Procedure: sort! items less
 -- C Function: scm_sort_x (items, less)
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  The sorting is
     destructive, that means that the input sequence is modified to
     produce the sorted result.  This is not a stable sort.

 -- Scheme Procedure: stable-sort items less
 -- C Function: scm_stable_sort (items, less)
     Sort the sequence ITEMS, which may be a list or a vector. LESS is
     used for comparing the sequence elements.  This is a stable sort.

 -- Scheme Procedure: stable-sort! items less
 -- C Function: scm_stable_sort_x (items, less)
     Sort the sequence ITEMS, which may be a list or a vector. LESS is
     used for comparing the sequence elements.  The sorting is
     destructive, that means that the input sequence is modified to
     produce the sorted result.  This is a stable sort.

   The procedures in the last group only accept lists or vectors as
input, as their names indicate.

 -- Scheme Procedure: sort-list items less
 -- C Function: scm_sort_list (items, less)
     Sort the list ITEMS, using LESS for comparing the list elements.
     This is a stable sort.

 -- Scheme Procedure: sort-list! items less
 -- C Function: scm_sort_list_x (items, less)
     Sort the list ITEMS, using LESS for comparing the list elements.
     The sorting is destructive, that means that the input list is
     modified to produce the sorted result.  This is a stable sort.

 -- Scheme Procedure: restricted-vector-sort! vec less startpos endpos
 -- C Function: scm_restricted_vector_sort_x (vec, less, startpos,
          endpos)
     Sort the vector VEC, using LESS for comparing the vector elements.
     STARTPOS and ENDPOS delimit the range of the vector which gets
     sorted.  The return value is not specified.


File: guile.info,  Node: Copying,  Next: General Conversion,  Prev: Sorting,  Up: Utility Functions

24.4 Copying Deep Structures
============================

The procedures for copying lists (*note Lists::) only produce a flat
copy of the input list, and currently Guile does not even contain
procedures for copying vectors.  `copy-tree' can be used for these
application, as it does not only copy the spine of a list, but also
copies any pairs in the cars of the input lists.

 -- Scheme Procedure: copy-tree obj
 -- C Function: scm_copy_tree (obj)
     Recursively copy the data tree that is bound to OBJ, and return a
     pointer to the new data structure.  `copy-tree' recurses down the
     contents of both pairs and vectors (since both cons cells and
     vector cells may point to arbitrary objects), and stops recursing
     when it hits any other object.


File: guile.info,  Node: General Conversion,  Next: Hooks,  Prev: Copying,  Up: Utility Functions

24.5 General String Conversion
==============================

When debugging Scheme programs, but also for providing a human-friendly
interface, a procedure for converting any Scheme object into string
format is very useful.  Conversion from/to strings can of course be done
with specialized procedures when the data type of the object to convert
is known, but with this procedure, it is often more comfortable.

   `object->string' converts an object by using a print procedure for
writing to a string port, and then returning the resulting string.
Converting an object back from the string is only possible if the object
type has a read syntax and the read syntax is preserved by the printing
procedure.

 -- Scheme Procedure: object->string obj [printer]
 -- C Function: scm_object_to_string (obj, printer)
     Return a Scheme string obtained by printing OBJ.  Printing
     function can be specified by the optional second argument PRINTER
     (default: `write').


File: guile.info,  Node: Hooks,  Prev: General Conversion,  Up: Utility Functions

24.6 Hooks
==========

A hook is a list of procedures to be called at well defined points in
time.  Typically, an application provides a hook H and promises its
users that it will call all of the procedures in H at a defined point
in the application's processing.  By adding its own procedure to H, an
application user can tap into or even influence the progress of the
application.

   Guile itself provides several such hooks for debugging and
customization purposes: these are listed in a subsection below.

   When an application first creates a hook, it needs to know how many
arguments will be passed to the hook's procedures when the hook is run.
The chosen number of arguments (which may be none) is declared when the
hook is created, and all the procedures that are added to that hook must
be capable of accepting that number of arguments.

   A hook is created using `make-hook'.  A procedure can be added to or
removed from a hook using `add-hook!' or `remove-hook!', and all of a
hook's procedures can be removed together using `reset-hook!'.  When an
application wants to run a hook, it does so using `run-hook'.

* Menu:

* Hook Example::                Hook usage by example.
* Hook Reference::              Reference of all hook procedures.
* C Hooks::                     Hooks for use from C code.
* Guile Hooks::                 Hooks provided by Guile.


File: guile.info,  Node: Hook Example,  Next: Hook Reference,  Up: Hooks

24.6.1 Hook Usage by Example
----------------------------

Hook usage is shown by some examples in this section.  First, we will
define a hook of arity 2 -- that is, the procedures stored in the hook
will have to accept two arguments.

     (define hook (make-hook 2))
     hook
     => #<hook 2 40286c90>

   Now we are ready to add some procedures to the newly created hook
with `add-hook!'.  In the following example, two procedures are added,
which print different messages and do different things with their
arguments.

     (add-hook! hook (lambda (x y)
                         (display "Foo: ")
                         (display (+ x y))
                         (newline)))
     (add-hook! hook (lambda (x y)
                         (display "Bar: ")
                         (display (* x y))
                         (newline)))

   Once the procedures have been added, we can invoke the hook using
`run-hook'.

     (run-hook hook 3 4)
     -| Bar: 12
     -| Foo: 7

   Note that the procedures are called in the reverse of the order with
which they were added.  This is because the default behaviour of
`add-hook!' is to add its procedure to the _front_ of the hook's
procedure list.  You can force `add-hook!' to add its procedure to the
_end_ of the list instead by providing a third `#t' argument on the
second call to `add-hook!'.

     (add-hook! hook (lambda (x y)
                         (display "Foo: ")
                         (display (+ x y))
                         (newline)))
     (add-hook! hook (lambda (x y)
                         (display "Bar: ")
                         (display (* x y))
                         (newline))
                         #t)             ; <- Change here!

     (run-hook hook 3 4)
     -| Foo: 7
     -| Bar: 12


File: guile.info,  Node: Hook Reference,  Next: C Hooks,  Prev: Hook Example,  Up: Hooks

24.6.2 Hook Reference
---------------------

When you create a hook with `make-hook', you must specify the arity of
the procedures which can be added to the hook.  If the arity is not
given explicitly as an argument to `make-hook', it defaults to zero.
All procedures of a given hook must have the same arity, and when the
procedures are invoked using `run-hook', the number of arguments passed
must match the arity specified at hook creation time.

   The order in which procedures are added to a hook matters.  If the
third parameter to `add-hook!' is omitted or is equal to `#f', the
procedure is added in front of the procedures which might already be on
that hook, otherwise the procedure is added at the end.  The procedures
are always called from the front to the end of the list when they are
invoked via `run-hook'.

   The ordering of the list of procedures returned by `hook->list'
matches the order in which those procedures would be called if the hook
was run using `run-hook'.

   Note that the C functions in the following entries are for handling
"Scheme-level" hooks in C.  There are also "C-level" hooks which have
their own interface (*note C Hooks::).

 -- Scheme Procedure: make-hook [n_args]
 -- C Function: scm_make_hook (n_args)
     Create a hook for storing procedure of arity N_ARGS.  N_ARGS
     defaults to zero.  The returned value is a hook object to be used
     with the other hook procedures.

 -- Scheme Procedure: hook? x
 -- C Function: scm_hook_p (x)
     Return `#t' if X is a hook, `#f' otherwise.

 -- Scheme Procedure: hook-empty? hook
 -- C Function: scm_hook_empty_p (hook)
     Return `#t' if HOOK is an empty hook, `#f' otherwise.

 -- Scheme Procedure: add-hook! hook proc [append_p]
 -- C Function: scm_add_hook_x (hook, proc, append_p)
     Add the procedure PROC to the hook HOOK. The procedure is added to
     the end if APPEND_P is true, otherwise it is added to the front.
     The return value of this procedure is not specified.

 -- Scheme Procedure: remove-hook! hook proc
 -- C Function: scm_remove_hook_x (hook, proc)
     Remove the procedure PROC from the hook HOOK.  The return value of
     this procedure is not specified.

 -- Scheme Procedure: reset-hook! hook
 -- C Function: scm_reset_hook_x (hook)
     Remove all procedures from the hook HOOK.  The return value of
     this procedure is not specified.

 -- Scheme Procedure: hook->list hook
 -- C Function: scm_hook_to_list (hook)
     Convert the procedure list of HOOK to a list.

 -- Scheme Procedure: run-hook hook . args
 -- C Function: scm_run_hook (hook, args)
     Apply all procedures from the hook HOOK to the arguments ARGS.
     The order of the procedure application is first to last.  The
     return value of this procedure is not specified.

   If, in C code, you are certain that you have a hook object and well
formed argument list for that hook, you can also use `scm_c_run_hook',
which is identical to `scm_run_hook' but does no type checking.

 -- C Function: void scm_c_run_hook (SCM hook, SCM args)
     The same as `scm_run_hook' but without any type checking to confirm
     that HOOK is actually a hook object and that ARGS is a well-formed
     list matching the arity of the hook.

   For C code, `SCM_HOOKP' is a faster alternative to `scm_hook_p':

 -- C Macro: int SCM_HOOKP (x)
     Return 1 if X is a Scheme-level hook, 0 otherwise.

24.6.3 Handling Scheme-level hooks from C code
----------------------------------------------

Here is an example of how to handle Scheme-level hooks from C code using
the above functions.

     if (SCM_NFALSEP (scm_hook_p (obj)))
       /* handle Scheme-level hook using C functions */
       scm_reset_hook_x (obj);
     else
       /* do something else (obj is not a hook) */


File: guile.info,  Node: C Hooks,  Next: Guile Hooks,  Prev: Hook Reference,  Up: Hooks

24.6.4 Hooks For C Code.
------------------------

The hooks already described are intended to be populated by Scheme-level
procedures.  In addition to this, the Guile library provides an
independent set of interfaces for the creation and manipulation of hooks
that are designed to be populated by functions implemented in C.

   The original motivation here was to provide a kind of hook that could
safely be invoked at various points during garbage collection.
Scheme-level hooks are unsuitable for this purpose as running them could
itself require memory allocation, which would then invoke garbage
collection recursively ...  However, it is also the case that these
hooks are easier to work with than the Scheme-level ones if you only
want to register C functions with them.  So if that is mainly what your
code needs to do, you may prefer to use this interface.

   To create a C hook, you should allocate storage for a structure of
type `scm_t_c_hook' and then initialize it using `scm_c_hook_init'.

 -- C Type: scm_t_c_hook
     Data type for a C hook.  The internals of this type should be
     treated as opaque.

 -- C Enum: scm_t_c_hook_type
     Enumeration of possible hook types, which are:

    `SCM_C_HOOK_NORMAL'
          Type of hook for which all the registered functions will
          always be called.

    `SCM_C_HOOK_OR'
          Type of hook for which the sequence of registered functions
          will be called only until one of them returns C true (a
          non-NULL pointer).

    `SCM_C_HOOK_AND'
          Type of hook for which the sequence of registered functions
          will be called only until one of them returns C false (a NULL
          pointer).

 -- C Function: void scm_c_hook_init (scm_t_c_hook *hook, void
          *hook_data, scm_t_c_hook_type type)
     Initialize the C hook at memory pointed to by HOOK.  TYPE should
     be one of the values of the `scm_t_c_hook_type' enumeration, and
     controls how the hook functions will be called.  HOOK_DATA is a
     closure parameter that will be passed to all registered hook
     functions when they are called.

   To add or remove a C function from a C hook, use `scm_c_hook_add' or
`scm_c_hook_remove'.  A hook function must expect three `void *'
parameters which are, respectively:

HOOK_DATA
     The hook closure data that was specified at the time the hook was
     initialized by `scm_c_hook_init'.

FUNC_DATA
     The function closure data that was specified at the time that that
     function was registered with the hook by `scm_c_hook_add'.

DATA
     The call closure data specified by the `scm_c_hook_run' call that
     runs the hook.

 -- C Type: scm_t_c_hook_function
     Function type for a C hook function: takes three `void *'
     parameters and returns a `void *' result.

 -- C Function: void scm_c_hook_add (scm_t_c_hook *hook,
          scm_t_c_hook_function func, void *func_data, int appendp)
     Add function FUNC, with function closure data FUNC_DATA, to the C
     hook HOOK.  The new function is appended to the hook's list of
     functions if APPENDP is non-zero, otherwise prepended.

 -- C Function: void scm_c_hook_remove (scm_t_c_hook *hook,
          scm_t_c_hook_function func, void *func_data)
     Remove function FUNC, with function closure data FUNC_DATA, from
     the C hook HOOK.  `scm_c_hook_remove' checks both FUNC and
     FUNC_DATA so as to allow for the same FUNC being registered
     multiple times with different closure data.

   Finally, to invoke a C hook, call the `scm_c_hook_run' function
specifying the hook and the call closure data for this run:

 -- C Function: void * scm_c_hook_run (scm_t_c_hook *hook, void *data)
     Run the C hook HOOK will call closure data DATA.  Subject to the
     variations for hook types `SCM_C_HOOK_OR' and `SCM_C_HOOK_AND',
     `scm_c_hook_run' calls HOOK's registered functions in turn,
     passing them the hook's closure data, each function's closure
     data, and the call closure data.

     `scm_c_hook_run''s return value is the return value of the last
     function to be called.


File: guile.info,  Node: Guile Hooks,  Prev: C Hooks,  Up: Hooks

24.6.5 Hooks Provided by Guile
------------------------------

* Menu:

* GC Hooks::                    Garbage collection hooks.
* REPL Hooks::                  Hooks into the Guile REPL.


File: guile.info,  Node: GC Hooks,  Next: REPL Hooks,  Up: Guile Hooks

24.6.5.1 Hooks for Garbage Collection
.....................................

Whenever Guile performs a garbage collection, it calls the following
hooks in the order shown.

 -- C Hook: scm_before_gc_c_hook
     C hook called at the very start of a garbage collection, after
     setting `scm_gc_running_p' to 1, but before entering the GC
     critical section.

     If garbage collection is blocked because `scm_block_gc' is
     non-zero, GC exits early soon after calling this hook, and no
     further hooks will be called.

 -- C Hook: scm_before_mark_c_hook
     C hook called before beginning the mark phase of garbage
     collection, after the GC thread has entered a critical section.

 -- C Hook: scm_before_sweep_c_hook
     C hook called before beginning the sweep phase of garbage
     collection.  This is the same as at the end of the mark phase,
     since nothing else happens between marking and sweeping.

 -- C Hook: scm_after_sweep_c_hook
     C hook called after the end of the sweep phase of garbage
     collection, but while the GC thread is still inside its critical
     section.

 -- C Hook: scm_after_gc_c_hook
     C hook called at the very end of a garbage collection, after the GC
     thread has left its critical section.

 -- Scheme Hook: after-gc-hook
     Scheme hook with arity 0.  This hook is run asynchronously (*note
     Asyncs::) soon after the GC has completed and any other events
     that were deferred during garbage collection have been processed.
     (Also accessible from C with the name `scm_after_gc_hook'.)

   All the C hooks listed here have type `SCM_C_HOOK_NORMAL', are
initialized with hook closure data NULL, are are invoked by
`scm_c_hook_run' with call closure data NULL.

   The Scheme hook `after-gc-hook' is particularly useful in
conjunction with guardians (*note Guardians::).  Typically, if you are
using a guardian, you want to call the guardian after garbage collection
to see if any of the objects added to the guardian have been collected.
By adding a thunk that performs this call to `after-gc-hook', you can
ensure that your guardian is tested after every garbage collection
cycle.


File: guile.info,  Node: REPL Hooks,  Prev: GC Hooks,  Up: Guile Hooks

24.6.5.2 Hooks into the Guile REPL
..................................


File: guile.info,  Node: Binding Constructs,  Next: Control Mechanisms,  Prev: Utility Functions,  Up: Top

25 Definitions and Variable Bindings
************************************

Scheme supports the definition of variables in different contexts.
Variables can be defined at the top level, so that they are visible in
the entire program, and variables can be defined locally to procedures
and expressions.  This is important for modularity and data abstraction.

* Menu:

* Top Level::                   Top level variable definitions.
* Local Bindings::              Local variable bindings.
* Internal Definitions::        Internal definitions.
* Binding Reflection::          Querying variable bindings.


File: guile.info,  Node: Top Level,  Next: Local Bindings,  Up: Binding Constructs

25.1 Top Level Variable Definitions
===================================

On the top level of a program (i.e. when not inside the body of a
procedure definition or a `let', `let*' or `letrec' expression), a
definition of the form

     (define a VALUE)

defines a variable called `a' and sets it to the value VALUE.

   If the variable already exists, because it has already been created
by a previous `define' expression with the same name, its value is
simply changed to the new VALUE.  In this case, then, the above form is
completely equivalent to

     (set! a VALUE)

This equivalence means that `define' can be used interchangeably with
`set!' to change the value of variables at the top level of the REPL or
a Scheme source file.  It is useful during interactive development when
reloading a Scheme file that you have modified, because it allows the
`define' expressions in that file to work as expected both the first
time that the file is loaded and on subsequent occasions.

   Note, though, that `define' and `set!' are not always equivalent.
For example, a `set!' is not allowed if the named variable does not
already exist, and the two expressions can behave differently in the
case where there are imported variables visible from another module.

 -- Scheme Syntax: define name value
     Create a top level variable named NAME with value VALUE.  If the
     named variable already exists, just change its value.  The return
     value of a `define' expression is unspecified.

   The C API equivalents of `define' are `scm_define' and
`scm_c_define', which differ from each other in whether the variable
name is specified as a `SCM' symbol or as a null-terminated C string.

 -- C Function: scm_define (sym, value)
 -- C Function: scm_c_define (const char *name, value)
     C equivalents of `define', with variable name specified either by
     SYM, a symbol, or by NAME, a null-terminated C string.  Both
     variants return the new or preexisting variable object.

   `define' (when it occurs at top level), `scm_define' and
`scm_c_define' all create or set the value of a variable in the top
level environment of the current module.  If there was not already a
variable with the specified name belonging to the current module, but a
similarly named variable from another module was visible through having
been imported, the newly created variable in the current module will
shadow the imported variable, such that the imported variable is no
longer visible.

   Attention: Scheme definitions inside local binding constructs (*note
Local Bindings::) act differently (*note Internal Definitions::).


File: guile.info,  Node: Local Bindings,  Next: Internal Definitions,  Prev: Top Level,  Up: Binding Constructs

25.2 Local Variable Bindings
============================

As opposed to definitions at the top level, which are visible in the
whole program (or current module, when Guile modules are used), it is
also possible to define variables which are only visible in a
well-defined part of the program.  Normally, this part of a program
will be a procedure or a subexpression of a procedure.

   With the constructs for local binding (`let', `let*' and `letrec'),
the Scheme language has a block structure like most other programming
languages since the days of ALGOL 60.  Readers familiar to languages
like C or Java should already be used to this concept, but the family
of `let' expressions has a few properties which are well worth knowing.

   The first local binding construct is `let'.  The other constructs
`let*' and `letrec' are specialized versions for usage where using
plain `let' is a bit inconvenient.

 -- syntax: let bindings body
     BINDINGS has the form

          ((VARIABLE1 INIT1) ...)

     that is zero or more two-element lists of a variable and an
     arbitrary expression each.  All VARIABLE names must be distinct.

     A `let' expression is evaluated as follows.

        * All INIT expressions are evaluated.

        * New storage is allocated for the VARIABLES.

        * The values of the INIT expressions are stored into the
          variables.

        * The expressions in BODY are evaluated in order, and the value
          of the last expression is returned as the value of the `let'
          expression.

        * The storage for the VARIABLES is freed.

     The INIT expressions are not allowed to refer to any of the
     VARIABLES.

 -- syntax: let* bindings body
     Similar to `let', but the variable bindings are performed
     sequentially, that means that all INIT expression are allowed to
     use the variables defined on their left in the binding list.

     A `let*' expression can always be expressed with nested `let'
     expressions.

          (let* ((a 1) (b a))
             b)
          ==
          (let ((a 1))
            (let ((b a))
              b))

 -- syntax: letrec bindings body
     Similar to `let', but it is possible to refer to the VARIABLE from
     lambda expression created in any of the INITS.  That is,
     procedures created in the INIT expression can recursively refer to
     the defined variables.

          (letrec ((even?
                    (lambda (n)
                        (if (zero? n)
                            #t
                            (odd? (- n 1)))))
                   (odd?
                    (lambda (n)
                        (if (zero? n)
                            #f
                            (even? (- n 1))))))
            (even? 88))
          =>
          #t

   There is also an alternative form of the `let' form, which is used
for expressing iteration.  Because of the use as a looping construct,
this form (the "named let") is documented in the section about
iteration (*note Iteration: while do.)


File: guile.info,  Node: Internal Definitions,  Next: Binding Reflection,  Prev: Local Bindings,  Up: Binding Constructs

25.3 Internal definitions
=========================

A `define' form which appears inside the body of a `lambda', `let',
`let*', `letrec' or equivalent expression is called an "internal
definition".  An internal definition differs from a top level
definition (*note Top Level::), because the definition is only visible
inside the complete body of the enclosing form.  Let us examine the
following example.

     (let ((frumble "froz"))
        (define banana (lambda () (apple 'peach)))
        (define apple (lambda (x) x))
        (banana))
     =>
     peach

   Here the enclosing form is a `let', so the `define's in the
`let'-body are internal definitions.  Because the scope of the internal
definitions is the *complete* body of the `let'-expression, the
`lambda'-expression which gets bound to the variable `banana' may refer
to the variable `apple', even though it's definition appears lexically
_after_ the definition of `banana'.  This is because a sequence of
internal definition acts as if it were a `letrec' expression.

     (let ()
       (define a 1)
       (define b 2)
       (+ a b))

is equivalent to

     (let ()
       (letrec ((a 1) (b 2))
         (+ a b)))

   Another noteworthy difference to top level definitions is that within
one group of internal definitions all variable names must be distinct.
That means where on the top level a second define for a given variable
acts like a `set!', an exception is thrown for internal definitions
with duplicate bindings.


File: guile.info,  Node: Binding Reflection,  Prev: Internal Definitions,  Up: Binding Constructs

25.4 Querying variable bindings
===============================

Guile provides a procedure for checking whether a symbol is bound in the
top level environment.

 -- Scheme Procedure: defined? sym [env]
 -- C Function: scm_definedp (sym, env)
     Return `#t' if SYM is defined in the lexical environment ENV.
     When ENV is not specified, look in the top-level environment as
     defined by the current module.


File: guile.info,  Node: Control Mechanisms,  Next: Input and Output,  Prev: Binding Constructs,  Up: Top

26 Controlling the Flow of Program Execution
********************************************

* Menu:

* begin::                       Evaluating a sequence of expressions.
* if cond case::                Simple conditional evaluation.
* and or::                      Conditional evaluation of a sequence.
* while do::                    Iteration mechanisms.
* Continuations::               Continuations.
* Multiple Values::             Returning and accepting multiple values.
* Exceptions::                  Throwing and catching exceptions.
* Error Reporting::             Procedures for signaling errors.
* Dynamic Wind::                Guarding against non-local entrance/exit.
* Handling Errors::             How to handle errors in C code.


File: guile.info,  Node: begin,  Next: if cond case,  Up: Control Mechanisms

26.1 Evaluating a Sequence of Expressions
=========================================

`begin' is used for grouping several expression together so that they
syntactically are treated as if they were one expression.  This is
particularly important when syntactic expressions are used which only
allow one expression, but the programmer wants to use more than one
expression in that place.  As an example, consider the conditional
expression below:

     (if (> x 0)
         (begin (display "greater") (newline)))

   If the two calls to `display' and `newline' were not embedded in a
`begin'-statement, the call to `newline' would get misinterpreted as
the else-branch of the `if'-expression.

 -- syntax: begin expr1 expr2 ...
     The expression(s) are evaluated in left-to-right order and the
     value of the last expression is returned as the value of the
     `begin'-expression.  This expression type is used when the
     expressions before the last one are evaluated for their side
     effects.


File: guile.info,  Node: if cond case,  Next: and or,  Prev: begin,  Up: Control Mechanisms

26.2 Simple Conditional Evaluation
==================================

Guile provides three syntactic constructs for conditional evaluation.
`if' is the normal if-then-else expression (with an optional else
branch), `cond' is a conditional expression with multiple branches and
`case' branches if an expression has one of a set of constant values.

 -- syntax: if test consequent [alternate]
     All arguments may be arbitrary expressions.  First, TEST is
     evaluated.  If it returns a true value, the expression CONSEQUENT
     is evaluated and ALTERNATE is ignored.  If TEST evaluates to `#f',
     ALTERNATE is evaluated instead.  The value of the evaluated branch
     (CONSEQUENT or ALTERNATE) is returned as the value of the `if'
     expression.

     When ALTERNATE is omitted and the TEST evaluates to `#f', the
     value of the expression is not specified.

 -- syntax: cond clause1 clause2 ...
     Each `cond'-clause must look like this:

          (TEST EXPRESSION ...)

     where TEST and EXPRESSION are arbitrary expression, or like this

          (TEST => EXPRESSION

     where EXPRESSION must evaluate to a procedure.

     The TESTs of the clauses are evaluated in order and as soon as one
     of them evaluates to a true values, the corresponding EXPRESSIONs
     are evaluated in order and the last value is returned as the value
     of the `cond'-expression.  For the `=>' clause type, EXPRESSION is
     evaluated and the resulting procedure is applied to the value of
     TEST.  The result of this procedure application is then the result
     of the `cond'-expression.

     The TEST of the last CLAUSE may be the keyword `else'.  Then, if
     none of the preceding TESTs is true, the EXPRESSIONs following the
     `else' are evaluated to produce the result of the
     `cond'-expression.

 -- syntax: case key clause1 clause2 ...
     KEY may be any expression, the CLAUSEs must have the form

          ((DATUM1 ...) EXPR1 EXPR2 ...)

     and the last CLAUSE may have the form

          (else EXPR1 EXPR2 ...)

     All DATUMs must be distinct.  First, KEY is evaluated.  The the
     result of this evaluation is compared against all DATUMs using
     `eqv?'.  When this comparison succeeds, the expression(s) following
     the DATUM are evaluated from left to right, returning the value of
     the last expression as the result of the `case' expression.

     If the KEY matches no DATUM and there is an `else'-clause, the
     expressions following the `else' are evaluated.  If there is no
     such clause, the result of the expression is unspecified.


File: guile.info,  Node: and or,  Next: while do,  Prev: if cond case,  Up: Control Mechanisms

26.3 Conditional Evaluation of a Sequence of Expressions
========================================================

`and' and `or' evaluate all their arguments, similar to `begin', but
evaluation stops as soon as one of the expressions evaluates to false
or true, respectively.

 -- syntax: and expr ...
     Evaluate the EXPRs from left to right and stop evaluation as soon
     as one expression evaluates to `#f'; the remaining expressions are
     not evaluated.  The value of the last evaluated expression is
     returned.  If no expression evaluates to `#f', the value of the
     last expression is returned.

     If used without expressions, `#t' is returned.

 -- syntax: or expr ...
     Evaluate the EXPRs from left to right and stop evaluation as soon
     as one expression evaluates to a true value (that is, a value
     different from `#f'); the remaining expressions are not evaluated.
     The value of the last evaluated expression is returned.  If all
     expressions evaluate to `#f', `#f' is returned.

     If used without expressions, `#f' is returned.


File: guile.info,  Node: while do,  Next: Continuations,  Prev: and or,  Up: Control Mechanisms

26.4 Iteration mechanisms
=========================

Scheme has only few iteration mechanisms, mainly because iteration in
Scheme programs is normally expressed using recursion.  Nevertheless,
R5RS defines a construct for programming loops, calling `do'.  In
addition, Guile has an explicit looping syntax called `while'.

 -- syntax: do ((variable1 init1 step1) ...) (test expr ...) command ...
     The INIT expressions are evaluated and the VARIABLES are bound to
     their values. Then looping starts with testing the TEST
     expression.  If TEST evaluates to a true value, the EXPR following
     the TEST are evaluated and the value of the last EXPR is returned
     as the value of the `do' expression.  If TEST evaluates to false,
     the COMMANDs are evaluated in order, the STEPs are evaluated and
     stored into the VARIABLES and the next iteration starts.

     Any of the STEP expressions may be omitted, so that the
     corresponding variable is not changed during looping.

 -- syntax: while cond body ...
     Evaluate all expressions in BODY in order, as long as COND
     evaluates to a true value.  The COND expression is tested before
     every iteration, so that the body is not evaluated at all if COND
     is `#f' right from the start.

   Another very common way of expressing iteration in Scheme programs is
the use of the so-called "named let".

   Named let is a variant of `let' which creates a procedure and calls
it in one step.  Because of the newly created procedure, named let is
more powerful than `do'-it can be used for iteration, but also for
arbitrary recursion.

 -- syntax: let variable bindings body
     For the definition of BINDINGS see the documentation about `let'
     (*note Local Bindings::).

     Named `let' works as follows:

        * A new procedure which accepts as many arguments as are in
          BINDINGS is created and bound locally (using `let') to
          VARIABLE.  The new procedure's formal argument names are the
          name of the VARIABLES.

        * The BODY expressions are inserted into the newly created
          procedure.

        * The procedure is called with the INIT expressions as the
          formal arguments.

     The next example implements a loop which iterates (by recursion)
     1000 times.

          (let lp ((x 1000))
            (if (positive? x)
                (lp (- x 1))
                x))
          =>
          0


File: guile.info,  Node: Continuations,  Next: Multiple Values,  Prev: while do,  Up: Control Mechanisms

26.5 Continuations
==================

The ability to explicitly capture continuations using
`call-with-current-continuation' (also often called `call/cc' for
short), and to invoke such continuations later any number of times, and
from any other point in a program, provides maybe the most powerful
control structure known.  All other control structures, such as loops
and coroutines, can be emulated using continuations.

   The implementation of continuations in Guile is not as efficient as
one might hope, because it is constrained by the fact that Guile is
designed to cooperate with programs written in other languages, such as
C, which do not know about continuations.  So continuations should be
used when there is no other simple way of achieving the desired
behaviour, or where the advantages of the elegant continuation
mechanism outweigh the need for optimum performance.  If you find
yourself using `call/cc' for escape procedures and your program is
running too slow, you might want to use exceptions (*note Exceptions::)
instead.

 -- Scheme Procedure: call-with-current-continuation proc
     Capture the current continuation and call PROC with the captured
     continuation as the single argument.  This continuation can then be
     called with arbitrarily many arguments.  Such a call will work
     like a goto to the invocation location of
     `call-with-current-continuation', passing the arguments in a way
     that they are returned by the call to
     `call-with-current-continuation'.  Since it is legal to store the
     captured continuation in a variable or to pass it to other
     procedures, it is possible that a procedure returns more than
     once, even if it is called only one time.  This can be confusing
     at times.

     (define kont #f)
     (call-with-current-continuation
       (lambda (k)
          (set! kont k)
          1))
     =>
     1

     (kont 2)
     =>
     2


File: guile.info,  Node: Multiple Values,  Next: Exceptions,  Prev: Continuations,  Up: Control Mechanisms

26.6 Returning and Accepting Multiple Values
============================================

Scheme allows a procedure to return more than one value to its caller.
This is quite different to other languages which only allow
single-value returns.  Returning multiple values is different from
returning a list (or pair or vector) of values to the caller, because
conceptually not _one_ compound object is returned, but several
distinct values.

   The primitive procedures for handling multiple values are `values'
and `call-with-values'.  `values' is used for returning multiple values
from a procedure.  This is done by placing a call to `values' with zero
or more arguments in tail position in a procedure body.
`call-with-values' combines a procedure returning multiple values with
a procedure which accepts these values as parameters.

 -- Scheme Procedure: values . args
 -- C Function: scm_values (args)
     Delivers all of its arguments to its continuation.  Except for
     continuations created by the `call-with-values' procedure, all
     continuations take exactly one value.  The effect of passing no
     value or more than one value to continuations that were not
     created by `call-with-values' is unspecified.

 -- Scheme Procedure: call-with-values producer consumer
     Calls its PRODUCER argument with no values and a continuation
     that, when passed some values, calls the CONSUMER procedure with
     those values as arguments.  The continuation for the call to
     CONSUMER is the continuation of the call to `call-with-values'.

          (call-with-values (lambda () (values 4 5))
                            (lambda (a b) b))
                                                       ==>  5

          (call-with-values * -)                             ==>  -1

   In addition to the fundamental procedures described above, Guile has
a module which exports a syntax called `receive', which is much more
convenient.  If you want to use it in your programs, you have to load
the module `(ice-9 receive)' with the statement

     (use-modules (ice-9 receive))

 -- library syntax: receive formals expr body ...
     Evaluate the expression EXPR, and bind the result values (zero or
     more) to the formal arguments in the formal argument list FORMALS.
     FORMALS must have the same syntax like the formal argument list
     used in `lambda' (*note Lambda::).  After binding the variables,
     the expressions in BODY ... are evaluated in order.


File: guile.info,  Node: Exceptions,  Next: Error Reporting,  Prev: Multiple Values,  Up: Control Mechanisms

26.7 Exceptions
===============

A common requirement in applications is to want to jump "non-locally"
from the depths of a computation back to, say, the application's main
processing loop.  Usually, the place that is the target of the jump is
somewhere in the calling stack of procedures that called the procedure
that wants to jump back.  For example, typical logic for a key press
driven application might look something like this:

     main-loop:
       read the next key press and call dispatch-key

     dispatch-key:
       lookup the key in a keymap and call an appropriate procedure,
       say find-file

     find-file:
       interactively read the required file name, then call
       find-specified-file

     find-specified-file:
       check whether file exists; if not, jump back to main-loop
       ...

   The jump back to `main-loop' could be achieved by returning through
the stack one procedure at a time, using the return value of each
procedure to indicate the error condition, but Guile (like most modern
programming languages) provides an additional mechanism called
"exception handling" that can be used to implement such jumps much more
conveniently.

* Menu:

* Exception Terminology::       Different ways to say the same thing.
* Catch::                       Setting up to catch exceptions.
* Throw::                       Throwing an exception.
* Lazy Catch::                  Catch without unwinding the stack.
* Exception Implementation::    How Guile implements exceptions.


File: guile.info,  Node: Exception Terminology,  Next: Catch,  Up: Exceptions

26.7.1 Exception Terminology
----------------------------

There are several variations on the terminology for dealing with
non-local jumps.  It is useful to be aware of them, and to realize that
they all refer to the same basic mechanism.

   * Actually making a non-local jump may be called "raising an
     exception", "raising a signal", "throwing an exception" or "doing
     a long jump".  When the jump indicates an error condition, people
     may talk about "signalling", "raising" or "throwing" "an error".

   * Handling the jump at its target may be referred to as "catching" or
     "handling" the "exception", "signal" or, where an error condition
     is involved, "error".

   Where "signal" and "signalling" are used, special care is needed to
avoid the risk of confusion with POSIX signals.  (Especially
considering that Guile handles POSIX signals by throwing a corresponding
kind of exception: REFFIXME.)

   This manual prefers to speak of throwing and catching exceptions,
since this terminology matches the corresponding Guile primitives.


File: guile.info,  Node: Catch,  Next: Throw,  Prev: Exception Terminology,  Up: Exceptions

26.7.2 Catching Exceptions
--------------------------

`catch' is used to set up a target for a possible non-local jump.  The
arguments of a `catch' expression are a "key", which restricts the set
of exceptions to which this `catch' applies, a thunk that specifies the
"normal case" code -- i.e. what should happen if no exceptions are
thrown -- and a "handler" procedure that says what to do if an
exception is thrown.  Note that if the "normal case" thunk executes
"normally", which means without throwing any exceptions, the handler
procedure is not executed at all.

   When an exception is thrown using the `throw' primitive, the first
argument of the `throw' is a symbol that indicates the type of the
exception.  For example, Guile throws an exception using the symbol
`numerical-overflow' to indicate numerical overflow errors such as
division by zero:

     (/ 1 0)
     =>
     ABORT: (numerical-overflow)

   The KEY argument in a `catch' expression corresponds to this symbol.
KEY may be a specific symbol, such as `numerical-overflow', in which
case the `catch' applies specifically to exceptions of that type; or it
may be `#t', which means that the `catch' applies to all exceptions,
irrespective of their type.

   The second argument of a `catch' expression should be a thunk (i.e.
a procedure that accepts no arguments) that specifies the normal case
code.  The `catch' is active for the execution of this thunk, including
any code called directly or indirectly by the thunk's body.  Evaluation
of the `catch' expression activates the catch and then calls this thunk.

   The third argument of a `catch' expression is a handler procedure.
If an exception is thrown, this procedure is called with exactly the
arguments specified by the `throw'.  Therefore, the handler procedure
must be designed to accept a number of arguments that corresponds to
the number of arguments in all `throw' expressions that can be caught
by this `catch'.

 -- Scheme Procedure: catch key thunk handler
 -- C Function: scm_catch (key, thunk, handler)
     Invoke THUNK in the dynamic context of HANDLER for exceptions
     matching KEY.  If thunk throws to the symbol KEY, then HANDLER is
     invoked this way:
          (handler key args ...)

     KEY is a symbol or `#t'.

     THUNK takes no arguments.  If THUNK returns normally, that is the
     return value of `catch'.

     Handler is invoked outside the scope of its own `catch'.  If
     HANDLER again throws to the same key, a new handler from further
     up the call chain is invoked.

     If the key is `#t', then a throw to _any_ symbol will match this
     call to `catch'.

   If the handler procedure needs to match a variety of `throw'
expressions with varying numbers of arguments, you should write it like
this:

     (lambda (key . args)
       ...)

The KEY argument is guaranteed always to be present, because a `throw'
without a KEY is not valid.  The number and interpretation of the ARGS
varies from one type of exception to another, but should be specified
by the documentation for each exception type.

   Note that, once the handler procedure is invoked, the catch that led
to the handler procedure being called is no longer active.  Therefore,
if the handler procedure itself throws an exception, that exception can
only be caught by another active catch higher up the call stack, if
there is one.


File: guile.info,  Node: Throw,  Next: Lazy Catch,  Prev: Catch,  Up: Exceptions

26.7.3 Throwing Exceptions
--------------------------

The `throw' primitive is used to throw an exception.  One argument, the
KEY, is mandatory, and must be a symbol; it indicates the type of
exception that is being thrown.  Following the KEY, `throw' accepts any
number of additional arguments, whose meaning depends on the exception
type.  The documentation for each possible type of exception should
specify the additional arguments that are expected for that kind of
exception.

 -- Scheme Procedure: throw key . args
 -- C Function: scm_throw (key, args)
     Invoke the catch form matching KEY, passing ARGS to the HANDLER.

     KEY is a symbol.  It will match catches of the same symbol or of
     `#t'.

     If there is no handler at all, Guile prints an error and then
     exits.

   When an exception is thrown, it will be caught by the innermost
`catch' expression that applies to the type of the thrown exception; in
other words, the innermost `catch' whose KEY is `#t' or is the same
symbol as that used in the `throw' expression.  Once Guile has
identified the appropriate `catch', it handles the exception by
applying that `catch' expression's handler procedure to the arguments
of the `throw'.

   If there is no appropriate `catch' for a thrown exception, Guile
prints an error to the current error port indicating an uncaught
exception, and then exits.  In practice, it is quite difficult to
observe this behaviour, because Guile when used interactively installs a
top level `catch' handler that will catch all exceptions and print an
appropriate error message _without_ exiting.  For example, this is what
happens if you try to throw an unhandled exception in the standard
Guile REPL; note that Guile's command loop continues after the error
message:

     guile> (throw 'badex)
     <unnamed port>:3:1: In procedure gsubr-apply ...
     <unnamed port>:3:1: unhandled-exception: badex
     ABORT: (misc-error)
     guile>

   The default uncaught exception behaviour can be observed by
evaluating a `throw' expression from the shell command line:

     $ guile -c "(begin (throw 'badex) (display \"here\\n\"))"
     guile: uncaught throw to badex: ()
     $

That Guile exits immediately following the uncaught exception is shown
by the absence of any output from the `display' expression, because
Guile never gets to the point of evaluating that expression.


File: guile.info,  Node: Lazy Catch,  Next: Exception Implementation,  Prev: Throw,  Up: Exceptions

26.7.4 Catch Without Unwinding
------------------------------

A "lazy catch" is used in the same way as a normal `catch', with KEY,
THUNK and HANDLER arguments specifying the exception type, normal case
code and handler procedure, but differs in one important respect: the
handler procedure is executed without unwinding the call stack from the
context of the `throw' expression that caused the handler to be invoked.

 -- Scheme Procedure: lazy-catch key thunk handler
 -- C Function: scm_lazy_catch (key, thunk, handler)
     This behaves exactly like `catch', except that it does not unwind
     the stack before invoking HANDLER.  The HANDLER procedure is not
     allowed to return: it must throw to another catch, or otherwise
     exit non-locally.

   Typically, HANDLER should save any desired state associated with the
stack at the point where the corresponding `throw' occurred, and then
throw an exception itself -- usually the same exception as the one it
caught.  If HANDLER is invoked and does _not_ throw an exception, Guile
itself throws an exception with key `misc-error'.

   Not unwinding the stack means that throwing an exception that is
caught by a `lazy-catch' is _almost_ equivalent to calling the
`lazy-catch''s handler inline instead of each `throw', and then
omitting the surrounding `lazy-catch'.  In other words,

     (lazy-catch 'key
       (lambda () ... (throw 'key args ...) ...)
       handler)

is _almost_ equivalent to

     ((lambda () ... (handler 'key args ...) ...))

But why only _almost_?  The difference is that with `lazy-catch' (as
with normal `catch'), the dynamic context is unwound back to just
outside the `lazy-catch' expression before invoking the handler.  (For
an introduction to what is meant by dynamic context, *Note Dynamic
Wind::.)

   Then, when the handler _itself_ throws an exception, that exception
must be caught by some kind of `catch' (including perhaps another
`lazy-catch') higher up the call stack.

   The dynamic context also includes `with-fluids' blocks (REFFIXME),
so the effect of unwinding the dynamic context can also be seen in fluid
variable values.  This is illustrated by the following code, in which
the normal case thunk uses `with-fluids' to temporarily change the
value of a fluid:

     (define f (make-fluid))
     (fluid-set! f "top level value")

     (define (handler . args)
       (cons (fluid-ref f) args))

     (lazy-catch 'foo
                 (lambda ()
                   (with-fluids ((f "local value"))
                     (throw 'foo)))
                 handler)
     =>
     ("top level value" foo)

     ((lambda ()
        (with-fluids ((f "local value"))
          (handler 'foo))))
     =>
     ("local value" foo)

In the `lazy-catch' version, the unwinding of dynamic context restores
`f' to its value outside the `with-fluids' block before the handler is
invoked, so the handler's `(fluid-ref f)' returns the external value.

   `lazy-catch' is useful because it permits the implementation of
debuggers and other reflective programming tools that need to access the
state of the call stack at the exact point where an exception or an
error is thrown.  For an example of this, see REFFIXME:stack-catch.


File: guile.info,  Node: Exception Implementation,  Prev: Lazy Catch,  Up: Exceptions

26.7.5 How Guile Implements Exceptions
--------------------------------------

It is traditional in Scheme to implement exception systems using
`call-with-current-continuation'.  Continuations (*note
Continuations::) are such a powerful concept that any other control
mechanism -- including `catch' and `throw' -- can be implemented in
terms of them.

   Guile does not implement `catch' and `throw' like this, though.  Why
not?  Because Guile is specifically designed to be easy to integrate
with applications written in C.  In a mixed Scheme/C environment, the
concept of "continuation" must logically include "what happens next" in
the C parts of the application as well as the Scheme parts, and it
turns out that the only reasonable way of implementing continuations
like this is to save and restore the complete C stack.

   So Guile's implementation of `call-with-current-continuation' is a
stack copying one.  This allows it to interact well with ordinary C
code, but means that creating and calling a continuation is slowed down
by the time that it takes to copy the C stack.

   The more targeted mechanism provided by `catch' and `throw' does not
need to save and restore the C stack because the `throw' always jumps
to a location higher up the stack of the code that executes the
`throw'.  Therefore Guile implements the `catch' and `throw' primitives
independently of `call-with-current-continuation', in a way that takes
advantage of this _upwards only_ nature of exceptions.


File: guile.info,  Node: Error Reporting,  Next: Dynamic Wind,  Prev: Exceptions,  Up: Control Mechanisms

26.8 Procedures for Signaling Errors
====================================

Guile provides a set of convenience procedures for signaling error
conditions that are implemented on top of the exception primitives just
described.

 -- Scheme Procedure: error msg args ...
     Raise an error with key `misc-error' and a message constructed by
     displaying MSG and writing ARGS.

 -- Scheme Procedure: scm-error key subr message args data
 -- C Function: scm_error_scm (key, subr, message, args, data)
     Raise an error with key KEY.  SUBR can be a string naming the
     procedure associated with the error, or `#f'.  MESSAGE is the
     error message string, possibly containing `~S' and `~A' escapes.
     When an error is reported, these are replaced by formatting the
     corresponding members of ARGS: `~A' (was `%s' in older versions of
     Guile) formats using `display' and `~S' (was `%S') formats using
     `write'.  DATA is a list or `#f' depending on KEY: if KEY is
     `system-error' then it should be a list containing the Unix
     `errno' value; If KEY is `signal' then it should be a list
     containing the Unix signal number; otherwise it will usually be
     `#f'.

 -- Scheme Procedure: strerror err
 -- C Function: scm_strerror (err)
     Return the Unix error message corresponding to ERR, which must be
     an integer value.

 -- syntax: false-if-exception expr
     Returns the result of evaluating its argument; however if an
     exception occurs then `#f' is returned instead.


File: guile.info,  Node: Dynamic Wind,  Next: Handling Errors,  Prev: Error Reporting,  Up: Control Mechanisms

26.9 Dynamic Wind
=================

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

 -- Scheme Procedure: dynamic-wind in_guard thunk out_guard
 -- C Function: scm_dynamic_wind (in_guard, thunk, out_guard)
     All three arguments must be 0-argument procedures.  IN_GUARD is
     called, then THUNK, then OUT_GUARD.

     If, any time during the execution of THUNK, the continuation of
     the `dynamic_wind' expression is escaped non-locally, OUT_GUARD is
     called.  If the continuation of the dynamic-wind is re-entered,
     IN_GUARD is called.  Thus IN_GUARD and OUT_GUARD may be called any
     number of times.
          (define x 'normal-binding)
          => x
          (define a-cont  (call-with-current-continuation
          		  (lambda (escape)
          		     (let ((old-x x))
          		       (dynamic-wind
          			  ;; in-guard:
          			  ;;
          			  (lambda () (set! x 'special-binding))

          			  ;; thunk
          			  ;;
          		 	  (lambda () (display x) (newline)
          				     (call-with-current-continuation escape)
          				     (display x) (newline)
          				     x)

          			  ;; out-guard:
          			  ;;
          			  (lambda () (set! x old-x)))))))

          ;; Prints:
          special-binding
          ;; Evaluates to:
          => a-cont
          x
          => normal-binding
          (a-cont #f)
          ;; Prints:
          special-binding
          ;; Evaluates to:
          => a-cont  ;; the value of the (define a-cont...)
          x
          => normal-binding
          a-cont
          => special-binding

